#!/usr/bin/env bash
#
# SecV - Enhanced with Module-Specific Help System
# Version: 2.1.0
#

# Configuration
readonly VERSION="2.1.0"
readonly SECV_HOME="${SECV_HOME:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
readonly TOOLS_DIR="$SECV_HOME/tools"
readonly CACHE_DIR="$SECV_HOME/.cache"
readonly DB_FILE="$CACHE_DIR/modules.db"

# Colors
R=$'\e[31m' G=$'\e[32m' Y=$'\e[33m' B=$'\e[34m' C=$'\e[36m' M=$'\e[35m' N=$'\e[0m' BOLD=$'\e[1m'

# Module registry
declare -a MOD_NAMES MOD_PATHS MOD_CATS MOD_DESCS MOD_EXECS
declare -a PARAM_KEYS PARAM_VALUES
CURRENT_MODULE="" CURRENT_PATH="" CURRENT_EXEC=""
MODULE_COUNT=0

# ============================================================================
# ENHANCED JSON PARSER
# ============================================================================

json_get() {
    local json="$1" key="$2"
    echo "$json" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    keys = '$key'.split('.')
    result = data
    for k in keys:
        result = result.get(k, '')
    print(result if isinstance(result, str) else json.dumps(result))
except:
    pass
" 2>/dev/null
}

json_has_key() {
    local json="$1" key="$2"
    echo "$json" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    keys = '$key'.split('.')
    result = data
    for k in keys:
        if k not in result:
            print('false')
            sys.exit()
        result = result[k]
    print('true')
except:
    print('false')
" 2>/dev/null
}

# ============================================================================
# MODULE HELP SYSTEM
# ============================================================================

show_module_help() {
    local module_name="$1"
    local module_path=""
    
    # Find module path
    for ((i=0; i<MODULE_COUNT; i++)); do
        if [[ "${MOD_NAMES[$i]}" == "$module_name" ]]; then
            module_path="${MOD_PATHS[$i]}"
            break
        fi
    done
    
    if [[ -z "$module_path" ]]; then
        echo -e "${R}Module '$module_name' not found${N}"
        return 1
    fi
    
    local json_file="$module_path/module.json"
    if [[ ! -f "$json_file" ]]; then
        echo -e "${R}module.json not found for '$module_name'${N}"
        return 1
    fi
    
    # Check if module has built-in help
    local executable="${MOD_EXECS[$i]}"
    if [[ -n "$executable" ]]; then
        cd "$module_path"
        if timeout 2 bash -c "$executable --help 2>/dev/null" 2>/dev/null; then
            cd - >/dev/null
            return 0
        elif timeout 2 bash -c "$executable -h 2>/dev/null" 2>/dev/null; then
            cd - >/dev/null
            return 0
        elif timeout 2 bash -c "$executable help 2>/dev/null" 2>/dev/null; then
            cd - >/dev/null
            return 0
        fi
        cd - >/dev/null
    fi
    
    # Parse and display help from module.json
    local json=$(<"$json_file")
    
    echo -e "\n${C}${BOLD}╔═══════════════════════════════════════════════════════════════════╗${N}"
    echo -e "${C}${BOLD}║  Module: $module_name${N}"
    echo -e "${C}${BOLD}╚═══════════════════════════════════════════════════════════════════╝${N}\n"
    
    # Basic Info
    local desc=$(json_get "$json" "description")
    local author=$(json_get "$json" "author")
    local version=$(json_get "$json" "version")
    local category=$(json_get "$json" "category")
    
    echo -e "${B}Description:${N} $desc"
    echo -e "${B}Author:${N} $author"
    echo -e "${B}Version:${N} $version"
    echo -e "${B}Category:${N} $category"
    
    # Check for help section
    if [[ $(json_has_key "$json" "help") == "true" ]]; then
        display_enhanced_help "$json"
    else
        display_basic_help "$json"
    fi
    
    # Check for README
    if [[ -f "$module_path/README.md" ]]; then
        echo -e "\n${Y}📖 Detailed documentation: $module_path/README.md${N}"
    fi
    
    echo
}

display_enhanced_help() {
    local json="$1"
    
    # Features
    local features=$(json_get "$json" "help.features")
    if [[ -n "$features" && "$features" != "[]" ]]; then
        echo -e "\n${G}${BOLD}Features:${N}"
        echo "$features" | python3 -c "
import json, sys
try:
    features = json.load(sys.stdin)
    for f in features:
        print(f'  • {f}')
except:
    pass
"
    fi
    
    # Parameters
    echo -e "\n${G}${BOLD}Parameters:${N}"
    local params=$(json_get "$json" "help.parameters")
    if [[ -n "$params" && "$params" != "{}" ]]; then
        echo "$params" | python3 -c "
import json, sys
try:
    params = json.load(sys.stdin)
    for name, info in params.items():
        print(f'  \033[33m{name}\033[0m')
        if isinstance(info, dict):
            if 'description' in info:
                print(f'    {info[\"description\"]}')
            if 'options' in info:
                print(f'    Options: {\" | \".join(info[\"options\"])}')
            if 'examples' in info:
                print(f'    Examples: {\" | \".join(info[\"examples\"])}')
            if 'default' in info:
                print(f'    Default: {info[\"default\"]}')
        else:
            print(f'    {info}')
        print()
except Exception as e:
    pass
"
    else
        display_inputs "$json"
    fi
    
    # Examples
    local examples=$(json_get "$json" "help.examples")
    if [[ -n "$examples" && "$examples" != "[]" ]]; then
        echo -e "\n${G}${BOLD}Usage Examples:${N}"
        echo "$examples" | python3 -c "
import json, sys
try:
    examples = json.load(sys.stdin)
    for i, ex in enumerate(examples, 1):
        if isinstance(ex, dict):
            print(f'\n  {i}. {ex.get(\"description\", \"Example\")}')
            if 'commands' in ex:
                for cmd in ex['commands']:
                    print(f'     secV > \033[36m{cmd}\033[0m')
        else:
            print(f'  {i}. {ex}')
except:
    pass
"
    fi
    
    # Installation tiers
    local tiers=$(json_get "$json" "help.installation_tiers")
    if [[ -n "$tiers" && "$tiers" != "{}" ]]; then
        echo -e "\n${G}${BOLD}Installation Tiers:${N}"
        echo "$tiers" | python3 -c "
import json, sys
try:
    tiers = json.load(sys.stdin)
    for tier, desc in tiers.items():
        print(f'  \033[32m{tier.upper()}\033[0m: {desc}')
except:
    pass
"
    fi
    
    # Optional dependencies
    local opt_deps=$(json_get "$json" "optional_dependencies")
    if [[ -n "$opt_deps" && "$opt_deps" != "{}" ]]; then
        echo -e "\n${Y}${BOLD}Optional Dependencies:${N}"
        echo "$opt_deps" | python3 -c "
import json, sys
try:
    deps = json.load(sys.stdin)
    for dep, desc in deps.items():
        print(f'  • \033[33m{dep}\033[0m: {desc}')
except:
    pass
"
    fi
    
    # Notes
    local notes=$(json_get "$json" "help.notes")
    if [[ -n "$notes" && "$notes" != "[]" ]]; then
        echo -e "\n${Y}${BOLD}Notes:${N}"
        echo "$notes" | python3 -c "
import json, sys
try:
    notes = json.load(sys.stdin)
    for note in notes:
        print(f'  ⚠ {note}')
except:
    pass
"
    fi
}

display_basic_help() {
    local json="$1"
    
    # Display inputs if available
    display_inputs "$json"
    
    # Display outputs if available
    local outputs=$(json_get "$json" "outputs")
    if [[ -n "$outputs" && "$outputs" != "{}" ]]; then
        echo -e "\n${G}${BOLD}Expected Outputs:${N}"
        echo "$outputs" | python3 -c "
import json, sys
try:
    outputs = json.load(sys.stdin)
    for name, info in outputs.items():
        if isinstance(info, dict):
            desc = info.get('description', '')
            type_str = info.get('type', '')
            print(f'  \033[33m{name}\033[0m ({type_str}): {desc}')
        else:
            print(f'  \033[33m{name}\033[0m: {info}')
except:
    pass
"
    fi
}

display_inputs() {
    local json="$1"
    local inputs=$(json_get "$json" "inputs")
    
    if [[ -n "$inputs" && "$inputs" != "{}" ]]; then
        echo -e "\n${G}${BOLD}Input Parameters:${N}"
        echo "$inputs" | python3 -c "
import json, sys
try:
    inputs = json.load(sys.stdin)
    for name, info in inputs.items():
        if isinstance(info, dict):
            desc = info.get('description', '')
            required = '(required)' if info.get('required', False) else '(optional)'
            default = f\" [default: {info['default']}]\" if 'default' in info else ''
            print(f'  \033[33m{name}\033[0m {required}{default}')
            print(f'    {desc}')
        else:
            print(f'  \033[33m{name}\033[0m: {info}')
except:
    pass
"
    fi
}

# ============================================================================
# MODULE MANAGEMENT
# ============================================================================

scan_modules() {
    echo -e "${Y}Scanning modules...${N}"
    MODULE_COUNT=0
    MOD_NAMES=() MOD_PATHS=() MOD_CATS=() MOD_DESCS=() MOD_EXECS=()
    
    while IFS= read -r -d '' json_file; do
        local dir="${json_file%/*}"
        local json=$(<"$json_file")
        
        local name=$(json_get "$json" "name")
        local cat=$(json_get "$json" "category")
        local desc=$(json_get "$json" "description")
        local exec=$(json_get "$json" "executable")
        
        if [[ -n "$name" ]]; then
            MOD_NAMES+=("$name")
            MOD_PATHS+=("$dir")
            MOD_CATS+=("$cat")
            MOD_DESCS+=("$desc")
            MOD_EXECS+=("$exec")
            ((MODULE_COUNT++))
        fi
    done < <(find "$TOOLS_DIR" -name "module.json" -type f -print0 2>/dev/null)
    
    echo -e "${G}✓ Loaded $MODULE_COUNT modules${N}"
}

load_cache() {
    [[ ! -f "$DB_FILE" ]] && return 1
    
    local age=$(($(date +%s) - $(stat -c %Y "$DB_FILE" 2>/dev/null || echo 0)))
    [[ $age -gt 3600 ]] && return 1
    
    MODULE_COUNT=0
    while IFS='|' read -r name path cat desc exec; do
        MOD_NAMES+=("$name")
        MOD_PATHS+=("$path")
        MOD_CATS+=("$cat")
        MOD_DESCS+=("$desc")
        MOD_EXECS+=("$exec")
        ((MODULE_COUNT++))
    done < "$DB_FILE" 2>/dev/null
    
    [[ $MODULE_COUNT -gt 0 ]] && echo -e "${G}✓ Loaded $MODULE_COUNT modules from cache${N}"
    return 0
}

# ============================================================================
# EXECUTION ENGINE
# ============================================================================

execute_module() {
    local target="$1"
    
    # Build JSON context
    local json="{\"target\":\"$target\",\"params\":{"
    local first=1
    for ((i=0; i<${#PARAM_KEYS[@]}; i++)); do
        [[ $first -eq 0 ]] && json+=","
        json+="\"${PARAM_KEYS[$i]}\":\"${PARAM_VALUES[$i]}\""
        first=0
    done
    json+="}}"
    
    echo -e "${Y}⚙ Executing $CURRENT_MODULE against $target...${N}"
    
    # Get timeout
    local timeout=300
    if [[ -f "$CURRENT_PATH/module.json" ]]; then
        local t=$(json_get "$(<"$CURRENT_PATH/module.json")" "timeout")
        [[ -n "$t" && "$t" != "null" ]] && timeout=$t
    fi
    
    # Execute
    local start=$(date +%s%N)
    
    cd "$CURRENT_PATH"
    echo "$json" | timeout $timeout bash -c "$CURRENT_EXEC"
    local ret=$?
    cd - >/dev/null 2>&1
    
    local end=$(date +%s%N)
    local elapsed=$(((end-start)/1000000))
    
    [[ $ret -eq 0 ]] && echo -e "${G}✓ Success (${elapsed}ms)${N}" || echo -e "${R}✗ Failed (${elapsed}ms)${N}"
    
    return $ret
}

# ============================================================================
# COMMANDS
# ============================================================================

cmd_show() {
    case "$1" in
        modules|"")
            echo -e "\n${C}${BOLD}Modules ($MODULE_COUNT total)${N}"
            local last_cat=""
            for ((i=0; i<MODULE_COUNT; i++)); do
                if [[ "${MOD_CATS[$i]}" != "$last_cat" ]]; then
                    echo -e "\n${Y}[${MOD_CATS[$i]}]${N}"
                    last_cat="${MOD_CATS[$i]}"
                fi
                printf "  ${G}%-20s${N} - %s\n" "${MOD_NAMES[$i]}" "${MOD_DESCS[$i]}"
            done | sort
            ;;
        categories)
            echo -e "\n${C}${BOLD}Categories${N}"
            printf '%s\n' "${MOD_CATS[@]}" | sort -u | while read cat; do
                local count=$(printf '%s\n' "${MOD_CATS[@]}" | grep -c "^$cat$")
                printf "  ${G}%-20s${N} : %d modules\n" "$cat" "$count"
            done
            ;;
        options)
            if [[ -z "$CURRENT_MODULE" ]]; then
                echo -e "${Y}No module loaded${N}"
            else
                echo -e "\n${C}${BOLD}Current Module: $CURRENT_MODULE${N}"
                echo -e "\n${G}Parameters:${N}"
                if [[ ${#PARAM_KEYS[@]} -eq 0 ]]; then
                    echo -e "  ${Y}No parameters set${N}"
                else
                    for ((i=0; i<${#PARAM_KEYS[@]}; i++)); do
                        printf "  ${Y}%-15s${N} => %s\n" "${PARAM_KEYS[$i]}" "${PARAM_VALUES[$i]}"
                    done
                fi
            fi
            ;;
    esac
    echo
}

cmd_use() {
    local module="$1"
    
    for ((i=0; i<MODULE_COUNT; i++)); do
        if [[ "${MOD_NAMES[$i]}" == "$module" ]]; then
            CURRENT_MODULE="$module"
            CURRENT_PATH="${MOD_PATHS[$i]}"
            CURRENT_EXEC="${MOD_EXECS[$i]}"
            PARAM_KEYS=() PARAM_VALUES=()
            
            echo -e "${G}✓ Loaded: $module${N}"
            echo -e "  Category: ${MOD_CATS[$i]}"
            echo -e "  Path: $CURRENT_PATH"
            echo -e "\n${C}Type 'help module' for detailed usage${N}"
            return 0
        fi
    done
    
    echo -e "${R}Module '$module' not found${N}"
    return 1
}

cmd_set() {
    [[ -z "$CURRENT_MODULE" ]] && echo -e "${Y}No module loaded${N}" && return
    
    local key="$1" value="$2"
    local found=0
    
    for ((i=0; i<${#PARAM_KEYS[@]}; i++)); do
        if [[ "${PARAM_KEYS[$i]}" == "$key" ]]; then
            PARAM_VALUES[$i]="$value"
            found=1
            break
        fi
    done
    
    [[ $found -eq 0 ]] && PARAM_KEYS+=("$key") && PARAM_VALUES+=("$value")
    echo -e "${G}$key => $value${N}"
}

cmd_run() {
    [[ -z "$CURRENT_MODULE" ]] && echo -e "${Y}No module loaded${N}" && return
    [[ -z "$1" ]] && echo -e "${R}Target required${N}" && return
    
    execute_module "$1"
}

cmd_search() {
    local query="$1"
    echo -e "\n${C}Search: '$query'${N}"
    
    for ((i=0; i<MODULE_COUNT; i++)); do
        if [[ "${MOD_NAMES[$i]}" == *"$query"* ]] || \
           [[ "${MOD_DESCS[$i]}" == *"$query"* ]] || \
           [[ "${MOD_CATS[$i]}" == *"$query"* ]]; then
            printf "  ${G}%-20s${N} [${Y}%s${N}] - %s\n" \
                "${MOD_NAMES[$i]}" "${MOD_CATS[$i]}" "${MOD_DESCS[$i]}"
        fi
    done
    echo
}

cmd_info() {
    local module="${1:-$CURRENT_MODULE}"
    
    if [[ -z "$module" ]]; then
        echo -e "${Y}No module specified or loaded${N}"
        return 1
    fi
    
    show_module_help "$module"
}

cmd_help() {
    local subcmd="$1"
    
    case "$subcmd" in
        module|modules)
            if [[ -n "$CURRENT_MODULE" ]]; then
                show_module_help "$CURRENT_MODULE"
            else
                echo -e "${Y}No module loaded. Use 'help module <name>' or load a module first${N}"
            fi
            ;;
        "")
            cat << 'HELP'

╔═══════════════════════════════════════════════════════════════════╗
║                    SecV Command Reference                         ║
╚═══════════════════════════════════════════════════════════════════╝

CORE COMMANDS:
  show [modules|categories|options]
                        List modules, categories, or current options
  
  use <module>          Load a security module
  
  set <key> <value>     Set module parameter
  
  run <target>          Execute loaded module against target
  
  info [module]         Show detailed module information
  
  help module [name]    Show help for current or specified module
  
  search <query>        Search modules by name, category, or description
  
  back                  Unload current module
  
  reload                Rescan module directory

MODULE HELP:
  help module           Show help for currently loaded module
  help module portscan  Show help for specific module
  info portscan         Alternative syntax for module help

EXAMPLES:
  Quick port scan:
    secV > use portscan
    secV (portscan) > help module
    secV (portscan) > run example.com
  
  Configure and run:
    secV > use portscan
    secV (portscan) > set ports top-100
    secV (portscan) > set engine syn
    secV (portscan) > run 192.168.1.1
  
  Search modules:
    secV > search web
    secV > search scan

TIPS:
  • Use 'info <module>' to see detailed help before loading
  • Type 'show options' after loading to see current settings
  • Most modules support --help: python3 module.py --help

HELP
            ;;
        *)
            echo -e "${Y}Unknown help topic. Try: help, help module${N}"
            ;;
    esac
}

# ============================================================================
# MAIN
# ============================================================================

main() {
    mkdir -p "$CACHE_DIR" "$TOOLS_DIR"
    
    # Banner
    echo -e "${C}╔═══════════════════════════════════════════════════════════════════╗"
    echo "║   ███████╗███████╗ ██████╗██╗   ██╗                             ║"
    echo "║   ██╔════╝██╔════╝██╔════╝██║   ██║                             ║"
    echo "║   ███████╗█████╗  ██║     ██║   ██║                             ║"
    echo "║   ╚════██║██╔══╝  ██║     ╚██╗ ██╔╝                             ║"
    echo "║   ███████║███████╗╚██████╗ ╚████╔╝                              ║"
    echo "║   ╚══════╝╚══════╝ ╚═════╝  ╚═══╝                               ║"
    echo "║                                                                   ║"
    echo "║   SecV v$VERSION - Enhanced with Module Help System              ║"
    echo "╚═══════════════════════════════════════════════════════════════════╝${N}"
    
    load_cache || scan_modules
    
    echo -e "${C}Type 'help' for commands, 'help module' for module help${N}\n"
    
    # Command loop
    while true; do
        if [[ -n "$CURRENT_MODULE" ]]; then
            printf "${G}secV ${R}($CURRENT_MODULE)${N} > "
        else
            printf "${G}secV${N} > "
        fi
        
        read -r cmd args
        
        case "$cmd" in
            show) cmd_show $args ;;
            use) cmd_use $args ;;
            set) cmd_set $args ;;
            run) cmd_run $args ;;
            search) cmd_search "$args" ;;
            info) cmd_info $args ;;
            help) cmd_help $args ;;
            back)
                CURRENT_MODULE="" CURRENT_PATH="" CURRENT_EXEC=""
                PARAM_KEYS=() PARAM_VALUES=()
                ;;
            reload)
                rm -f "$DB_FILE"
                scan_modules
                ;;
            clear) clear ;;
            exit|quit) echo -e "${C}Goodbye!${N}" && exit 0 ;;
            "") ;;
            *) echo -e "${Y}Unknown command: $cmd (type 'help')${N}" ;;
        esac
    done
}

[[ "${BASH_SOURCE[0]}" == "${0}" ]] && main "$@"
