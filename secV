#!/usr/bin/env bash
#
# SecV - Enhanced UI Version
# Version: 2.1.0
#

# Configuration
readonly VERSION="2.1.0"
readonly SECV_HOME="${SECV_HOME:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
readonly TOOLS_DIR="$SECV_HOME/tools"
readonly CACHE_DIR="$SECV_HOME/.cache"
readonly DB_FILE="$CACHE_DIR/modules.db"
readonly UPDATE_CHECK_FILE="$CACHE_DIR/.last_update_check"

# Only check for updates if:
# 1. We're in a git repository
# 2. It's been more than 24 hours since last check
# 3. User hasn't disabled auto-update
should_check_updates() {
    # Check if auto-update is disabled
    [[ -f "$CACHE_DIR/.no_auto_update" ]] && return 1
    
    # Check if we're in a git repo
    [[ ! -d "$SECV_HOME/.git" ]] && return 1
    
    # Check if update check file exists and is recent
    if [[ -f "$UPDATE_CHECK_FILE" ]]; then
        local last_check=$(cat "$UPDATE_CHECK_FILE" 2>/dev/null || echo 0)
        local now=$(date +%s)
        local age=$((now - last_check))
        
        # Only check if more than 24 hours (86400 seconds)
        [[ $age -lt 86400 ]] && return 1
    fi
    
    return 0
}

# Run updater check if appropriate
if should_check_updates; then
    if [[ -f "$SECV_HOME/update.py" ]]; then
        python3 "$SECV_HOME/update.py" 2>/dev/null
        echo "$(date +%s)" > "$UPDATE_CHECK_FILE"
    fi
fi

# Enhanced Colors & Styles
R=$'\e[31m' G=$'\e[32m' Y=$'\e[33m' B=$'\e[34m' C=$'\e[36m' M=$'\e[35m' W=$'\e[97m' N=$'\e[0m'
BOLD=$'\e[1m' DIM=$'\e[2m' ITALIC=$'\e[3m' UNDERLINE=$'\e[4m'
BG_DARK=$'\e[48;5;236m' BG_BLUE=$'\e[48;5;24m' BG_GREEN=$'\e[48;5;22m'

# Symbols
CHECK="✓" CROSS="✗" ARROW="➤" BULLET="•" STAR="★" GEAR="⚙"

# Module registry
declare -a MOD_NAMES MOD_PATHS MOD_CATS MOD_DESCS MOD_EXECS
declare -a PARAM_KEYS PARAM_VALUES
CURRENT_MODULE="" CURRENT_PATH="" CURRENT_EXEC=""
MODULE_COUNT=0

# ============================================================================
# ENHANCED JSON PARSER
# ============================================================================

json_get() {
    local json="$1" key="$2"
    echo "$json" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    keys = '$key'.split('.')
    result = data
    for k in keys:
        result = result.get(k, '')
    print(result if isinstance(result, str) else json.dumps(result))
except:
    pass
" 2>/dev/null
}

json_has_key() {
    local json="$1" key="$2"
    echo "$json" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    keys = '$key'.split('.')
    result = data
    for k in keys:
        if k not in result:
            print('false')
            sys.exit()
        result = result[k]
    print('true')
except:
    print('false')
" 2>/dev/null
}

# ============================================================================
# ENHANCED UI FUNCTIONS
# ============================================================================

print_header() {
    local text="$1"
    local width=67
    echo -e "\n${BOLD}${C}╔═$(printf '═%.0s' $(seq 1 $width))═╗${N}"
    echo -e "${BOLD}${C}║${N} ${BOLD}${W}$text${N}$(printf ' %.0s' $(seq 1 $((width - ${#text}))))${BOLD}${C}║${N}"
    echo -e "${BOLD}${C}╚═$(printf '═%.0s' $(seq 1 $width))═╝${N}"
}

print_box() {
    local text="$1"
    local color="${2:-$C}"
    echo -e "${color}┌─────────────────────────────────────────────────────────────────┐${N}"
    echo -e "${color}│${N} $text"
    echo -e "${color}└─────────────────────────────────────────────────────────────────┘${N}"
}

print_success() {
    echo -e "${G}${BOLD}${CHECK}${N} ${G}$1${N}"
}

print_error() {
    echo -e "${R}${BOLD}${CROSS}${N} ${R}$1${N}"
}

print_info() {
    echo -e "${B}${BOLD}${ARROW}${N} ${B}$1${N}"
}

print_warning() {
    echo -e "${Y}${BOLD}⚠${N}  ${Y}$1${N}"
}

# ============================================================================
# MODULE HELP SYSTEM
# ============================================================================

show_module_help() {
    local module_name="$1"
    local module_path=""
    
    # Find module path
    for ((i=0; i<MODULE_COUNT; i++)); do
        if [[ "${MOD_NAMES[$i]}" == "$module_name" ]]; then
            module_path="${MOD_PATHS[$i]}"
            break
        fi
    done
    
    if [[ -z "$module_path" ]]; then
        print_error "Module '$module_name' not found"
        return 1
    fi
    
    local json_file="$module_path/module.json"
    if [[ ! -f "$json_file" ]]; then
        print_error "module.json not found for '$module_name'"
        return 1
    fi
    
    # Check if module has built-in help
    local executable="${MOD_EXECS[$i]}"
    if [[ -n "$executable" ]]; then
        cd "$module_path"
        if timeout 2 bash -c "$executable --help 2>/dev/null" 2>/dev/null; then
            cd - >/dev/null
            return 0
        elif timeout 2 bash -c "$executable -h 2>/dev/null" 2>/dev/null; then
            cd - >/dev/null
            return 0
        elif timeout 2 bash -c "$executable help 2>/dev/null" 2>/dev/null; then
            cd - >/dev/null
            return 0
        fi
        cd - >/dev/null
    fi
    
    # Parse and display help from module.json
    local json=$(<"$json_file")
    
    print_header "Module: $module_name"
    
    # Basic Info
    local desc=$(json_get "$json" "description")
    local author=$(json_get "$json" "author")
    local version=$(json_get "$json" "version")
    local category=$(json_get "$json" "category")
    
    echo -e "\n${BOLD}${DIM}Description:${N} $desc"
    echo -e "${BOLD}${DIM}Author:${N} ${M}$author${N}"
    echo -e "${BOLD}${DIM}Version:${N} ${C}$version${N}"
    echo -e "${BOLD}${DIM}Category:${N} ${Y}$category${N}"
    
    # Check for help section
    if [[ $(json_has_key "$json" "help") == "true" ]]; then
        display_enhanced_help "$json"
    else
        display_basic_help "$json"
    fi
    
    # Check for README
    if [[ -f "$module_path/README.md" ]]; then
        echo -e "\n${DIM}${ITALIC}📖 Detailed documentation: ${UNDERLINE}$module_path/README.md${N}"
    fi
    
    echo
}

display_enhanced_help() {
    local json="$1"
    
    # Features
    local features=$(json_get "$json" "help.features")
    if [[ -n "$features" && "$features" != "[]" ]]; then
        echo -e "\n${BOLD}${G}Features:${N}"
        echo "$features" | python3 -c "
import json, sys
try:
    features = json.load(sys.stdin)
    for f in features:
        print(f'  ${BULLET} {f}')
except:
    pass
"
    fi
    
    # Parameters
    echo -e "\n${BOLD}${Y}Parameters:${N}"
    local params=$(json_get "$json" "help.parameters")
    if [[ -n "$params" && "$params" != "{}" ]]; then
        echo "$params" | python3 -c "
import json, sys
try:
    params = json.load(sys.stdin)
    for name, info in params.items():
        print(f'  \033[1m\033[36m{name}\033[0m')
        if isinstance(info, dict):
            if 'description' in info:
                print(f'    \033[2m{info[\"description\"]}\033[0m')
            if 'options' in info:
                print(f'    \033[33mOptions:\033[0m {\" | \".join(info[\"options\"])}')
            if 'examples' in info:
                print(f'    \033[32mExamples:\033[0m {\" | \".join(info[\"examples\"])}')
            if 'default' in info:
                print(f'    \033[35mDefault:\033[0m {info[\"default\"]}')
        else:
            print(f'    \033[2m{info}\033[0m')
        print()
except Exception as e:
    pass
"
    else
        display_inputs "$json"
    fi
    
    # Examples
    local examples=$(json_get "$json" "help.examples")
    if [[ -n "$examples" && "$examples" != "[]" ]]; then
        echo -e "\n${BOLD}${B}Usage Examples:${N}"
        echo "$examples" | python3 -c "
import json, sys
try:
    examples = json.load(sys.stdin)
    for i, ex in enumerate(examples, 1):
        if isinstance(ex, dict):
            print(f'\n  \033[1m{i}. {ex.get(\"description\", \"Example\")}\033[0m')
            if 'commands' in ex:
                for cmd in ex['commands']:
                    print(f'     \033[2msecV >\033[0m \033[36m{cmd}\033[0m')
        else:
            print(f'  {i}. {ex}')
except:
    pass
"
    fi
    
    # Installation tiers
    local tiers=$(json_get "$json" "help.installation_tiers")
    if [[ -n "$tiers" && "$tiers" != "{}" ]]; then
        echo -e "\n${BOLD}${M}Installation Tiers:${N}"
        echo "$tiers" | python3 -c "
import json, sys
try:
    tiers = json.load(sys.stdin)
    for tier, desc in tiers.items():
        print(f'  \033[1m\033[32m{tier.upper()}\033[0m: \033[2m{desc}\033[0m')
except:
    pass
"
    fi
    
    # Optional dependencies
    local opt_deps=$(json_get "$json" "optional_dependencies")
    if [[ -n "$opt_deps" && "$opt_deps" != "{}" ]]; then
        echo -e "\n${BOLD}${Y}Optional Dependencies:${N}"
        echo "$opt_deps" | python3 -c "
import json, sys
try:
    deps = json.load(sys.stdin)
    for dep, desc in deps.items():
        print(f'  ${BULLET} \033[33m{dep}\033[0m: \033[2m{desc}\033[0m')
except:
    pass
"
    fi
    
    # Notes
    local notes=$(json_get "$json" "help.notes")
    if [[ -n "$notes" && "$notes" != "[]" ]]; then
        echo -e "\n${BOLD}${Y}Important Notes:${N}"
        echo "$notes" | python3 -c "
import json, sys
try:
    notes = json.load(sys.stdin)
    for note in notes:
        if note.startswith('⚠') or note.startswith('⚡'):
            print(f'  \033[33m{note}\033[0m')
        elif note.startswith('💡'):
            print(f'  \033[36m{note}\033[0m')
        else:
            print(f'  \033[2m⚠ {note}\033[0m')
except:
    pass
"
    fi
}

display_basic_help() {
    local json="$1"
    display_inputs "$json"
    
    local outputs=$(json_get "$json" "outputs")
    if [[ -n "$outputs" && "$outputs" != "{}" ]]; then
        echo -e "\n${BOLD}${G}Expected Outputs:${N}"
        echo "$outputs" | python3 -c "
import json, sys
try:
    outputs = json.load(sys.stdin)
    for name, info in outputs.items():
        if isinstance(info, dict):
            desc = info.get('description', '')
            type_str = info.get('type', '')
            print(f'  \033[36m{name}\033[0m \033[2m({type_str})\033[0m: {desc}')
        else:
            print(f'  \033[36m{name}\033[0m: {info}')
except:
    pass
"
    fi
}

display_inputs() {
    local json="$1"
    local inputs=$(json_get "$json" "inputs")
    
    if [[ -n "$inputs" && "$inputs" != "{}" ]]; then
        echo -e "\n${BOLD}${Y}Input Parameters:${N}"
        echo "$inputs" | python3 -c "
import json, sys
try:
    inputs = json.load(sys.stdin)
    for name, info in inputs.items():
        if isinstance(info, dict):
            desc = info.get('description', '')
            required = '\033[31m(required)\033[0m' if info.get('required', False) else '\033[2m(optional)\033[0m'
            default = f\" \033[35m[default: {info['default']}]\033[0m\" if 'default' in info else ''
            print(f'  \033[1m\033[36m{name}\033[0m {required}{default}')
            print(f'    \033[2m{desc}\033[0m')
        else:
            print(f'  \033[36m{name}\033[0m: {info}')
except:
    pass
"
    fi
}

# ============================================================================
# MODULE MANAGEMENT
# ============================================================================

scan_modules() {
    echo -e "${DIM}Scanning modules...${N}"
    MODULE_COUNT=0
    MOD_NAMES=() MOD_PATHS=() MOD_CATS=() MOD_DESCS=() MOD_EXECS=()
    
    while IFS= read -r -d '' json_file; do
        local dir="${json_file%/*}"
        local json=$(<"$json_file")
        
        local name=$(json_get "$json" "name")
        local cat=$(json_get "$json" "category")
        local desc=$(json_get "$json" "description")
        local exec=$(json_get "$json" "executable")
        
        if [[ -n "$name" ]]; then
            MOD_NAMES+=("$name")
            MOD_PATHS+=("$dir")
            MOD_CATS+=("$cat")
            MOD_DESCS+=("$desc")
            MOD_EXECS+=("$exec")
            ((MODULE_COUNT++))
        fi
    done < <(find "$TOOLS_DIR" -name "module.json" -type f -print0 2>/dev/null)
    
    print_success "Loaded $MODULE_COUNT modules"
}

load_cache() {
    [[ ! -f "$DB_FILE" ]] && return 1
    
    local age=$(($(date +%s) - $(stat -c %Y "$DB_FILE" 2>/dev/null || echo 0)))
    [[ $age -gt 3600 ]] && return 1
    
    MODULE_COUNT=0
    while IFS='|' read -r name path cat desc exec; do
        MOD_NAMES+=("$name")
        MOD_PATHS+=("$path")
        MOD_CATS+=("$cat")
        MOD_DESCS+=("$desc")
        MOD_EXECS+=("$exec")
        ((MODULE_COUNT++))
    done < "$DB_FILE" 2>/dev/null
    
    [[ $MODULE_COUNT -gt 0 ]] && print_success "Loaded $MODULE_COUNT modules from cache"
    return 0
}

# ============================================================================
# EXECUTION ENGINE
# ============================================================================

execute_module() {
    local target="$1"
    
    # Build JSON context
    local json="{\"target\":\"$target\",\"params\":{"
    local first=1
    for ((i=0; i<${#PARAM_KEYS[@]}; i++)); do
        [[ $first -eq 0 ]] && json+=","
        json+="\"${PARAM_KEYS[$i]}\":\"${PARAM_VALUES[$i]}\""
        first=0
    done
    json+="}}"
    
    echo -e "\n${BOLD}${C}${GEAR} Executing ${W}$CURRENT_MODULE${C} against ${Y}$target${C}...${N}"
    
    # Get timeout
    local timeout=300
    if [[ -f "$CURRENT_PATH/module.json" ]]; then
        local t=$(json_get "$(<"$CURRENT_PATH/module.json")" "timeout")
        [[ -n "$t" && "$t" != "null" ]] && timeout=$t
    fi
    
    # Execute
    local start=$(date +%s%N)
    
    cd "$CURRENT_PATH"
    echo "$json" | timeout $timeout bash -c "$CURRENT_EXEC"
    local ret=$?
    cd - >/dev/null 2>&1
    
    local end=$(date +%s%N)
    local elapsed=$(((end-start)/1000000))
    
    if [[ $ret -eq 0 ]]; then
        print_success "Completed in ${elapsed}ms"
    else
        print_error "Failed after ${elapsed}ms"
    fi
    
    return $ret
}

# ============================================================================
# ENHANCED COMMANDS
# ============================================================================

cmd_show() {
    case "$1" in
        modules|"")
            print_header "Available Modules ($MODULE_COUNT)"
            local last_cat=""
            for ((i=0; i<MODULE_COUNT; i++)); do
                if [[ "${MOD_CATS[$i]}" != "$last_cat" ]]; then
                    echo -e "\n${BOLD}${Y}[${MOD_CATS[$i]}]${N}"
                    last_cat="${MOD_CATS[$i]}"
                fi
                printf "  ${BOLD}${C}%-20s${N} ${DIM}│${N} %s\n" "${MOD_NAMES[$i]}" "${MOD_DESCS[$i]}"
            done | sort
            echo
            ;;
        categories)
            print_header "Module Categories"
            printf '%s\n' "${MOD_CATS[@]}" | sort -u | while read cat; do
                local count=$(printf '%s\n' "${MOD_CATS[@]}" | grep -c "^$cat$")
                printf "  ${BOLD}${Y}%-20s${N} ${DIM}→${N} ${G}%d modules${N}\n" "$cat" "$count"
            done
            echo
            ;;
        options)
            if [[ -z "$CURRENT_MODULE" ]]; then
                print_warning "No module loaded"
            else
                print_header "Module Configuration"
                echo -e "\n${BOLD}${C}Current Module:${N} ${W}$CURRENT_MODULE${N}"
                echo -e "\n${BOLD}${Y}Parameters:${N}"
                if [[ ${#PARAM_KEYS[@]} -eq 0 ]]; then
                    echo -e "  ${DIM}No parameters set${N}"
                else
                    for ((i=0; i<${#PARAM_KEYS[@]}; i++)); do
                        printf "  ${BOLD}${C}%-15s${N} ${DIM}→${N} ${G}%s${N}\n" "${PARAM_KEYS[$i]}" "${PARAM_VALUES[$i]}"
                    done
                fi
            fi
            echo
            ;;
    esac
}

cmd_use() {
    local module="$1"
    
    for ((i=0; i<MODULE_COUNT; i++)); do
        if [[ "${MOD_NAMES[$i]}" == "$module" ]]; then
            CURRENT_MODULE="$module"
            CURRENT_PATH="${MOD_PATHS[$i]}"
            CURRENT_EXEC="${MOD_EXECS[$i]}"
            PARAM_KEYS=() PARAM_VALUES=()
            
            print_success "Loaded: ${BOLD}$module${N}"
            echo -e "  ${DIM}Category:${N} ${Y}${MOD_CATS[$i]}${N}"
            echo -e "  ${DIM}Path:${N} ${B}$CURRENT_PATH${N}"
            echo -e "\n${C}${ITALIC}Type '${BOLD}help module${N}${C}${ITALIC}' for detailed usage${N}"
            return 0
        fi
    done
    
    print_error "Module '$module' not found"
    return 1
}

cmd_set() {
    [[ -z "$CURRENT_MODULE" ]] && print_warning "No module loaded" && return
    
    local key="$1" value="$2"
    local found=0
    
    for ((i=0; i<${#PARAM_KEYS[@]}; i++)); do
        if [[ "${PARAM_KEYS[$i]}" == "$key" ]]; then
            PARAM_VALUES[$i]="$value"
            found=1
            break
        fi
    done
    
    [[ $found -eq 0 ]] && PARAM_KEYS+=("$key") && PARAM_VALUES+=("$value")
    echo -e "${G}${BOLD}$key${N} ${DIM}→${N} ${C}$value${N}"
}

cmd_run() {
    [[ -z "$CURRENT_MODULE" ]] && print_warning "No module loaded" && return
    [[ -z "$1" ]] && print_error "Target required" && return
    
    execute_module "$1"
}

cmd_search() {
    local query="$1"
    print_header "Search: '$query'"
    
    local found=0
    for ((i=0; i<MODULE_COUNT; i++)); do
        if [[ "${MOD_NAMES[$i]}" == *"$query"* ]] || \
           [[ "${MOD_DESCS[$i]}" == *"$query"* ]] || \
           [[ "${MOD_CATS[$i]}" == *"$query"* ]]; then
            printf "  ${BOLD}${C}%-20s${N} ${DIM}[${Y}%s${DIM}]${N} %s\n" \
                "${MOD_NAMES[$i]}" "${MOD_CATS[$i]}" "${MOD_DESCS[$i]}"
            ((found++))
        fi
    done
    
    echo -e "\n${DIM}Found $found matching modules${N}\n"
}

cmd_info() {
    local module="${1:-$CURRENT_MODULE}"
    
    if [[ -z "$module" ]]; then
        print_warning "No module specified or loaded"
        return 1
    fi
    
    show_module_help "$module"
}

cmd_help() {
    local subcmd="$1"
    
    case "$subcmd" in
        module|modules)
            if [[ -n "$CURRENT_MODULE" ]]; then
                show_module_help "$CURRENT_MODULE"
            else
                print_warning "No module loaded. Use 'help module <name>' or load a module first"
            fi
            ;;
        "")
            print_header "SecV Command Reference"
            cat << 'HELP'

CORE COMMANDS:
  show [modules|categories|options]
      List modules, categories, or current configuration
  
  use <module>
      Load a security module
  
  set <key> <value>
      Configure module parameters
  
  run <target>
      Execute loaded module against target
  
  info [module]
      Display detailed module information
  
  help module [name]
      Show comprehensive module help
  
  search <query>
      Search modules by name, category, or description
  
  back
      Unload current module
  
  reload
      Rescan module directory
  
  clear
      Clear terminal screen
  
  exit | quit
      Exit SecV shell

QUICK START:
  1. Browse modules:    show modules
  2. Load module:       use portscan
  3. View help:         help module
  4. Configure:         set ports web
  5. Execute:           run example.com

TIPS:
  • Use 'info <module>' to preview help before loading
  • Tab completion available for commands
  • Type 'show options' to see current configuration
  • Most modules support --help flag directly

HELP
            echo
            ;;
        *)
            print_warning "Unknown help topic. Try: help, help module"
            ;;
    esac
}

# ============================================================================
# MAIN
# ============================================================================

main() {
    mkdir -p "$CACHE_DIR" "$TOOLS_DIR"
    
    # Enhanced Banner
    clear
    echo -e "${BOLD}${C}"
    cat << 'BANNER'
╔═══════════════════════════════════════════════════════════════════╗
║   ███████╗███████╗ ██████╗██╗   ██╗                             ║
║   ██╔════╝██╔════╝██╔════╝██║   ██║                             ║
║   ███████╗█████╗  ██║     ██║   ██║                             ║
║   ╚════██║██╔══╝  ██║     ╚██╗ ██╔╝                             ║
║   ███████║███████╗╚██████╗ ╚████╔╝                              ║
║   ╚══════╝╚══════╝ ╚═════╝  ╚═══╝                               ║
╚═══════════════════════════════════════════════════════════════════╝
BANNER
    echo -e "${N}"
    echo -e "${DIM}   SecV v$VERSION - Enhanced Module Help System${N}"
    echo -e "${DIM}   The Polyglot Cybersecurity Orchestration Platform${N}\n"
    
    load_cache || scan_modules
    
    echo -e "${DIM}${ITALIC}Type '${BOLD}help${N}${DIM}${ITALIC}' for commands, '${BOLD}help module${N}${DIM}${ITALIC}' for module help${N}\n"
    
    # Command loop with enhanced prompt
    while true; do
        if [[ -n "$CURRENT_MODULE" ]]; then
            printf "${BOLD}${G}secV${N} ${BOLD}${R}(${CURRENT_MODULE})${N} ${C}${ARROW}${N} "
        else
            printf "${BOLD}${G}secV${N} ${C}${ARROW}${N} "
        fi
        
        read -r cmd args
        
        case "$cmd" in
            show) cmd_show $args ;;
            use) cmd_use $args ;;
            set) cmd_set $args ;;
            run) cmd_run $args ;;
            search) cmd_search "$args" ;;
            info) cmd_info $args ;;
            help) cmd_help $args ;;
            update) cmd_update ;;
            autoupdate)
                cmd_no_auto_update
                ;;
            back)
                CURRENT_MODULE="" CURRENT_PATH="" CURRENT_EXEC=""
                PARAM_KEYS=() PARAM_VALUES=()
                print_info "Module unloaded"
                ;;
            reload)
                rm -f "$DB_FILE"
                scan_modules
                ;;
            clear) clear ;;
            exit|quit) 
                echo -e "\n${C}${BOLD}Thanks for using SecV! Stay ethical. ${STAR}${N}\n"
                exit 0 
                ;;
            "") ;;
            *) print_warning "Unknown command: $cmd ${DIM}(type 'help')${N}" ;;
        esac
    done
}

[[ "${BASH_SOURCE[0]}" == "${0}" ]] && main "$@"
