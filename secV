#!/usr/bin/env bash
#
# SecV - Complete Enhanced Shell v2.3.1
# Full implementation with all commands and features
#

# Configuration
readonly VERSION="2.3.1"

# Resolve actual script location (handles symlinks)
if [[ -L "${BASH_SOURCE[0]}" ]]; then
    SCRIPT_REAL_PATH="$(readlink -f "${BASH_SOURCE[0]}")"
    readonly SECV_HOME="$(cd "$(dirname "$SCRIPT_REAL_PATH")" && pwd)"
else
    readonly SECV_HOME="${SECV_HOME:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
fi

readonly TOOLS_DIR="$SECV_HOME/tools"
readonly CACHE_DIR="$SECV_HOME/.cache"
readonly DASHBOARD_PY="$SECV_HOME/dashboard.py"
readonly UPDATE_PY="$SECV_HOME/update.py"

# Enhanced Colors & Styles
R=$'\e[31m' G=$'\e[32m' Y=$'\e[33m' B=$'\e[34m' C=$'\e[36m' M=$'\e[35m' W=$'\e[97m' N=$'\e[0m'
BOLD=$'\e[1m' DIM=$'\e[2m' ITALIC=$'\e[3m' UNDERLINE=$'\e[4m'

# Symbols
CHECK="✓" CROSS="✗" ARROW="➤" BULLET="•" STAR="★" GEAR="⚙" WARNING="⚠"

# Module registry
declare -a MOD_NAMES MOD_PATHS MOD_CATS MOD_DESCS MOD_EXECS MOD_VERSIONS
declare -a PARAM_KEYS PARAM_VALUES
CURRENT_MODULE="" CURRENT_PATH="" CURRENT_EXEC=""
MODULE_COUNT=0
MODULE_JSON=""

# ============================================================================
# ENHANCED JSON PARSER
# ============================================================================

json_get() {
    local json="$1" key="$2"
    echo "$json" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    keys = '$key'.split('.')
    result = data
    for k in keys:
        if isinstance(result, dict):
            result = result.get(k, '')
        else:
            result = ''
            break
    if isinstance(result, (list, dict)):
        print(json.dumps(result))
    else:
        print(result if result else '')
except:
    pass
" 2>/dev/null
}

json_array_length() {
    local json="$1"
    echo "$json" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    if isinstance(data, list):
        print(len(data))
    else:
        print(0)
except:
    print(0)
" 2>/dev/null
}

# ============================================================================
# UI FUNCTIONS
# ============================================================================

print_header() {
    local text="$1"
    local width=67
    echo -e "\n${BOLD}${C}╔$(printf '═%.0s' $(seq 1 $width))╗${N}"
    echo -e "${BOLD}${C}║${N} ${BOLD}${W}$text${N}$(printf ' %.0s' $(seq 1 $((width - ${#text}))))${BOLD}${C}║${N}"
    echo -e "${BOLD}${C}╚$(printf '═%.0s' $(seq 1 $width))╝${N}"
}

print_success() {
    echo -e "${G}${BOLD}${CHECK}${N} ${G}$1${N}"
}

print_error() {
    echo -e "${R}${BOLD}${CROSS}${N} ${R}$1${N}"
}

print_info() {
    echo -e "${B}${BOLD}${ARROW}${N} ${B}$1${N}"
}

print_warning() {
    echo -e "${Y}${BOLD}${WARNING}${N}  ${Y}$1${N}"
}

print_section() {
    echo -e "\n${BOLD}${C}${1}:${N}"
    echo -e "${DIM}$(printf '─%.0s' $(seq 1 67))${N}"
}

# ============================================================================
# MODULE MANAGEMENT
# ============================================================================

scan_modules() {
    echo -e "${DIM}Scanning modules...${N}"
    MODULE_COUNT=0
    MOD_NAMES=() MOD_PATHS=() MOD_CATS=() MOD_DESCS=() MOD_EXECS=() MOD_VERSIONS=()
    
    if [[ ! -d "$TOOLS_DIR" ]]; then
        print_error "Tools directory not found: $TOOLS_DIR"
        echo -e "${YELLOW}Creating tools directory...${N}"
        mkdir -p "$TOOLS_DIR"
        echo -e "${BLUE}${ARROW} Tools directory created. Add modules to: $TOOLS_DIR${N}"
        return
    fi
    
    while IFS= read -r -d '' json_file; do
        local dir="${json_file%/*}"
        local json=$(<"$json_file")
        
        local name=$(json_get "$json" "name")
        local cat=$(json_get "$json" "category")
        local desc=$(json_get "$json" "description")
        local exec=$(json_get "$json" "executable")
        local ver=$(json_get "$json" "version")
        
        if [[ -n "$name" ]]; then
            MOD_NAMES+=("$name")
            MOD_PATHS+=("$dir")
            MOD_CATS+=("${cat:-uncategorized}")
            MOD_DESCS+=("${desc:-No description}")
            MOD_EXECS+=("$exec")
            MOD_VERSIONS+=("${ver:-1.0.0}")
            ((MODULE_COUNT++))
        fi
    done < <(find "$TOOLS_DIR" -name "module.json" -type f -print0 2>/dev/null)
    
    if [[ $MODULE_COUNT -eq 0 ]]; then
        print_warning "No modules found in: $TOOLS_DIR"
        echo -e "${BLUE}${ARROW} Add modules to: $TOOLS_DIR/<category>/<module-name>/module.json${N}"
    else
        print_success "Loaded $MODULE_COUNT modules"
    fi
}

# ============================================================================
# COMMANDS - MODULE SELECTION
# ============================================================================

cmd_use() {
    local module="$1"
    
    if [[ -z "$module" ]]; then
        print_error "Usage: use <module_name>"
        return 1
    fi
    
    for ((i=0; i<MODULE_COUNT; i++)); do
        if [[ "${MOD_NAMES[$i]}" == "$module" ]]; then
            CURRENT_MODULE="$module"
            CURRENT_PATH="${MOD_PATHS[$i]}"
            CURRENT_EXEC="${MOD_EXECS[$i]}"
            PARAM_KEYS=() PARAM_VALUES=()
            
            # Load module.json
            if [[ -f "$CURRENT_PATH/module.json" ]]; then
                MODULE_JSON=$(<"$CURRENT_PATH/module.json")
            else
                MODULE_JSON=""
            fi
            
            print_success "Loaded: ${BOLD}$module${N}"
            echo -e "  ${DIM}Category:${N} ${Y}${MOD_CATS[$i]}${N}"
            echo -e "  ${DIM}Version:${N} ${C}${MOD_VERSIONS[$i]}${N}"
            echo -e "  ${DIM}Path:${N} ${B}$CURRENT_PATH${N}"
            echo -e "\n${C}${ITALIC}Type '${BOLD}help module${N}${C}${ITALIC}' for detailed usage${N}"
            return 0
        fi
    done
    
    print_error "Module '$module' not found"
    echo -e "${DIM}Use 'show modules' to see available modules${N}"
    return 1
}

cmd_back() {
    if [[ -z "$CURRENT_MODULE" ]]; then
        print_warning "No module loaded"
        return 1
    fi
    
    CURRENT_MODULE="" CURRENT_PATH="" CURRENT_EXEC="" MODULE_JSON=""
    PARAM_KEYS=() PARAM_VALUES=()
    print_info "Module unloaded"
}

# ============================================================================
# COMMANDS - PARAMETERS
# ============================================================================

cmd_set() {
    if [[ -z "$CURRENT_MODULE" ]]; then
        print_warning "No module loaded. Use 'use <module>' first"
        return 1
    fi
    
    local key="$1" value="$2"
    
    if [[ -z "$key" || -z "$value" ]]; then
        print_error "Usage: set <parameter> <value>"
        return 1
    fi
    
    local found=0
    for ((i=0; i<${#PARAM_KEYS[@]}; i++)); do
        if [[ "${PARAM_KEYS[$i]}" == "$key" ]]; then
            PARAM_VALUES[$i]="$value"
            found=1
            break
        fi
    done
    
    [[ $found -eq 0 ]] && PARAM_KEYS+=("$key") && PARAM_VALUES+=("$value")
    echo -e "${G}${BOLD}$key${N} ${DIM}→${N} ${C}$value${N}"
}

cmd_unset() {
    if [[ -z "$CURRENT_MODULE" ]]; then
        print_warning "No module loaded"
        return 1
    fi
    
    local key="$1"
    
    if [[ -z "$key" ]]; then
        print_error "Usage: unset <parameter>"
        return 1
    fi
    
    local new_keys=() new_values=()
    local found=0
    
    for ((i=0; i<${#PARAM_KEYS[@]}; i++)); do
        if [[ "${PARAM_KEYS[$i]}" != "$key" ]]; then
            new_keys+=("${PARAM_KEYS[$i]}")
            new_values+=("${PARAM_VALUES[$i]}")
        else
            found=1
        fi
    done
    
    if [[ $found -eq 1 ]]; then
        PARAM_KEYS=("${new_keys[@]}")
        PARAM_VALUES=("${new_values[@]}")
        print_success "Unset: $key"
    else
        print_warning "Parameter '$key' not set"
    fi
}

# ============================================================================
# COMMANDS - EXECUTION
# ============================================================================

cmd_run() {
    if [[ -z "$CURRENT_MODULE" ]]; then
        print_warning "No module loaded. Use 'use <module>' first"
        return 1
    fi
    
    local target="$1"
    
    if [[ -z "$target" ]]; then
        print_error "Usage: run <target>"
        return 1
    fi
    
    # Build JSON context
    local json="{\"target\":\"$target\",\"params\":{"
    local first=1
    for ((i=0; i<${#PARAM_KEYS[@]}; i++)); do
        [[ $first -eq 0 ]] && json+=","
        local escaped_value=$(echo "${PARAM_VALUES[$i]}" | sed 's/"/\\"/g')
        json+="\"${PARAM_KEYS[$i]}\":\"${escaped_value}\""
        first=0
    done
    json+="}}"
    
    echo -e "\n${BOLD}${C}${GEAR} Executing ${W}$CURRENT_MODULE${C} against ${Y}$target${C}...${N}"
    
    if [[ ${#PARAM_KEYS[@]} -gt 0 ]]; then
        echo -e "${DIM}Parameters:${N}"
        for ((i=0; i<${#PARAM_KEYS[@]}; i++)); do
            echo -e "  ${DIM}${PARAM_KEYS[$i]}:${N} ${PARAM_VALUES[$i]}"
        done
    fi
    echo
    
    # Execute
    local start=$(date +%s)
    local output_file=$(mktemp)
    
    cd "$CURRENT_PATH" || return 1
    echo "$json" | bash -c "$CURRENT_EXEC" > "$output_file" 2>&1
    local ret=$?
    cd - >/dev/null 2>&1 || true
    
    local end=$(date +%s)
    local elapsed=$((end-start))
    
    # Display output
    cat "$output_file"
    rm -f "$output_file"
    
    if [[ $ret -eq 0 ]]; then
        print_success "Completed in ${elapsed}s"
    else
        print_error "Failed after ${elapsed}s (exit code: $ret)"
    fi
    
    return $ret
}

# ============================================================================
# COMMANDS - INFORMATION
# ============================================================================

cmd_show_modules() {
    print_header "Available Modules"
    
    if [[ $MODULE_COUNT -eq 0 ]]; then
        print_warning "No modules found"
        return
    fi
    
    # Group by category
    declare -A cats
    for ((i=0; i<MODULE_COUNT; i++)); do
        local cat="${MOD_CATS[$i]}"
        cats[$cat]=1
    done
    
    for cat in $(echo "${!cats[@]}" | tr ' ' '\n' | sort); do
        echo -e "\n${BOLD}${Y}${cat}${N}"
        echo -e "${DIM}$(printf '─%.0s' $(seq 1 67))${N}"
        
        for ((i=0; i<MODULE_COUNT; i++)); do
            if [[ "${MOD_CATS[$i]}" == "$cat" ]]; then
                local name="${MOD_NAMES[$i]}"
                local desc="${MOD_DESCS[$i]}"
                local ver="${MOD_VERSIONS[$i]}"
                
                printf "  ${BOLD}${C}%-20s${N} ${DIM}v%-8s${N} ${desc:0:35}\n" "$name" "$ver"
            fi
        done
    done
    
    echo -e "\n${DIM}Total: $MODULE_COUNT modules${N}"
    echo -e "${DIM}Use 'use <module>' to load a module${N}\n"
}

cmd_show_options() {
    if [[ -z "$CURRENT_MODULE" ]]; then
        print_warning "No module loaded. Use 'use <module>' first"
        return 1
    fi
    
    print_header "Module Options: $CURRENT_MODULE"
    
    # Show module info
    for ((i=0; i<MODULE_COUNT; i++)); do
        if [[ "${MOD_NAMES[$i]}" == "$CURRENT_MODULE" ]]; then
            echo -e "\n${DIM}Description:${N} ${MOD_DESCS[$i]}"
            echo -e "${DIM}Category:${N} ${Y}${MOD_CATS[$i]}${N}"
            echo -e "${DIM}Version:${N} ${C}${MOD_VERSIONS[$i]}${N}"
            break
        fi
    done
    
    # Show current parameters
    print_section "Current Parameters"
    
    if [[ ${#PARAM_KEYS[@]} -eq 0 ]]; then
        echo -e "${DIM}No parameters set${N}"
    else
        for ((i=0; i<${#PARAM_KEYS[@]}; i++)); do
            printf "  ${BOLD}%-20s${N} ${C}%s${N}\n" "${PARAM_KEYS[$i]}" "${PARAM_VALUES[$i]}"
        done
    fi
    
    # Show available parameters from module.json
    if [[ -n "$MODULE_JSON" ]]; then
        local inputs=$(json_get "$MODULE_JSON" "inputs")
        
        if [[ -n "$inputs" && "$inputs" != "{}" ]]; then
            print_section "Available Parameters"
            
            echo "$inputs" | python3 << 'PYEOF'
import json, sys

try:
    data = json.load(sys.stdin)
    for key, info in data.items():
        typ = info.get('type', 'string')
        desc = info.get('description', '')
        required = ' [REQUIRED]' if info.get('required', False) else ''
        print(f"  \033[1m{key}\033[0m \033[2m({typ}){required}\033[0m")
        if desc:
            print(f"    {desc}")
except:
    pass
PYEOF
        fi
    fi
    
    echo -e "\n${DIM}Use 'set <param> <value>' to configure parameters${N}\n"
}

cmd_info() {
    local module="${1:-$CURRENT_MODULE}"
    
    if [[ -z "$module" ]]; then
        print_error "Usage: info [module_name]"
        return 1
    fi
    
    local module_path=""
    local module_idx=-1
    
    for ((i=0; i<MODULE_COUNT; i++)); do
        if [[ "${MOD_NAMES[$i]}" == "$module" ]]; then
            module_path="${MOD_PATHS[$i]}"
            module_idx=$i
            break
        fi
    done
    
    if [[ -z "$module_path" ]]; then
        print_error "Module '$module' not found"
        return 1
    fi
    
    print_header "Module: $module"
    
    echo -e "\n${BOLD}${DIM}Name:${N} ${BOLD}${C}$module${N}"
    echo -e "${BOLD}${DIM}Version:${N} ${C}${MOD_VERSIONS[$module_idx]}${N}"
    echo -e "${BOLD}${DIM}Category:${N} ${Y}${MOD_CATS[$module_idx]}${N}"
    echo -e "${BOLD}${DIM}Description:${N} ${MOD_DESCS[$module_idx]}"
    echo -e "${BOLD}${DIM}Path:${N} ${B}$module_path${N}"
    
    # Show additional info from module.json
    local json_file="$module_path/module.json"
    if [[ -f "$json_file" ]]; then
        local json=$(<"$json_file")
        
        local author=$(json_get "$json" "author")
        [[ -n "$author" ]] && echo -e "${BOLD}${DIM}Author:${N} ${M}$author${N}"
        
        local deps=$(json_get "$json" "dependencies")
        if [[ -n "$deps" && "$deps" != "[]" ]]; then
            echo -e "\n${BOLD}${DIM}Dependencies:${N}"
            echo "$deps" | python3 -c "import json, sys; [print(f'  • {d}') for d in json.load(sys.stdin)]" 2>/dev/null
        fi
    fi
    
    if [[ -f "$module_path/README.md" ]]; then
        echo -e "\n${DIM}${ITALIC}📖 Detailed documentation: ${UNDERLINE}$module_path/README.md${N}"
    fi
    
    echo
}

cmd_search() {
    local query="$1"
    
    if [[ -z "$query" ]]; then
        print_error "Usage: search <keyword>"
        return 1
    fi
    
    print_header "Search Results: $query"
    
    local found=0
    
    for ((i=0; i<MODULE_COUNT; i++)); do
        local name="${MOD_NAMES[$i]}"
        local desc="${MOD_DESCS[$i]}"
        local cat="${MOD_CATS[$i]}"
        
        if [[ "$name" =~ $query ]] || [[ "$desc" =~ $query ]] || [[ "$cat" =~ $query ]]; then
            ((found++))
            echo -e "\n${BOLD}${C}$name${N} ${DIM}[${cat}]${N}"
            echo -e "  ${desc}"
        fi
    done
    
    if [[ $found -eq 0 ]]; then
        echo -e "\n${DIM}No modules found matching '$query'${N}"
    else
        echo -e "\n${DIM}Found $found module(s)${N}"
    fi
    echo
}

# ============================================================================
# COMMANDS - UTILITY
# ============================================================================

cmd_reload() {
    scan_modules
}

cmd_clear() {
    clear
    echo -e "${BOLD}${C}SecV v$VERSION${N} - ${DIM}Cleared${N}\n"
}

cmd_update() {
    if [[ -f "$UPDATE_PY" ]]; then
        echo -e "${C}${BOLD}Checking for updates...${N}\n"
        python3 "$UPDATE_PY"
    else
        print_error "Update script not found: $UPDATE_PY"
    fi
}

cmd_dashboard() {
    if [[ -f "$DASHBOARD_PY" ]]; then
        python3 "$DASHBOARD_PY" dashboard
    else
        print_error "Dashboard not available"
    fi
}

cmd_help() {
    local topic="$1"
    
    if [[ "$topic" == "module" ]]; then
        if [[ -z "$CURRENT_MODULE" ]]; then
            print_warning "No module loaded"
            return 1
        fi
        cmd_info "$CURRENT_MODULE"
        return
    fi
    
    print_header "SecV Command Reference"
    
    echo -e "\n${BOLD}${Y}MODULE SELECTION${N}"
    echo -e "  ${C}use <module>${N}          Load a module"
    echo -e "  ${C}back${N}                  Unload current module"
    echo -e "  ${C}reload${N}                Rescan modules directory"
    
    echo -e "\n${BOLD}${Y}CONFIGURATION${N}"
    echo -e "  ${C}set <param> <value>${N}   Set module parameter"
    echo -e "  ${C}unset <param>${N}         Remove parameter"
    echo -e "  ${C}show options${N}          Show module parameters"
    
    echo -e "\n${BOLD}${Y}EXECUTION${N}"
    echo -e "  ${C}run <target>${N}          Execute loaded module"
    
    echo -e "\n${BOLD}${Y}INFORMATION${N}"
    echo -e "  ${C}show modules${N}          List all modules"
    echo -e "  ${C}info [module]${N}         Show module details"
    echo -e "  ${C}search <keyword>${N}      Search modules"
    echo -e "  ${C}help module${N}           Show current module help"
    
    echo -e "\n${BOLD}${Y}UTILITIES${N}"
    echo -e "  ${C}update${N}                Update SecV"
    echo -e "  ${C}dashboard${N}             Show module dashboard"
    echo -e "  ${C}clear${N}                 Clear screen"
    echo -e "  ${C}exit${N}                  Exit SecV"
    
    echo -e "\n${DIM}Type 'help module' for current module help${N}\n"
}

# ============================================================================
# MAIN LOOP
# ============================================================================

main() {
    mkdir -p "$CACHE_DIR" "$TOOLS_DIR"
    
    # Banner
    clear
    echo -e "${BOLD}${C}"
    cat << 'BANNER'
╔═══════════════════════════════════════════════════════════════════╗
║   ███████╗███████╗ ██████╗██╗   ██╗                             ║
║   ██╔════╝██╔════╝██╔════╝██║   ██║                             ║
║   ███████╗█████╗  ██║     ██║   ██║                             ║
║   ╚════██║██╔══╝  ██║     ╚██╗ ██╔╝                             ║
║   ███████║███████╗╚██████╗ ╚████╔╝                              ║
║   ╚══════╝╚══════╝ ╚═════╝  ╚═══╝                               ║
╚═══════════════════════════════════════════════════════════════════╝
BANNER
    echo -e "${N}"
    echo -e "${DIM}   SecV v$VERSION - Enhanced Module Handling${N}"
    echo -e "${DIM}   The Polyglot Cybersecurity Orchestration Platform${N}\n"
    
    scan_modules
    
    echo -e "${DIM}${ITALIC}Type '${BOLD}help${N}${DIM}${ITALIC}' for commands${N}\n"
    
    # Command loop
    while true; do
        if [[ -n "$CURRENT_MODULE" ]]; then
            printf "${BOLD}${G}secV${N} ${BOLD}${R}(${CURRENT_MODULE})${N} ${C}${ARROW}${N} "
        else
            printf "${BOLD}${G}secV${N} ${C}${ARROW}${N} "
        fi
        
        read -r cmd args
        
        case "$cmd" in
            use) cmd_use $args ;;
            back) cmd_back ;;
            set) cmd_set $args ;;
            unset) cmd_unset $args ;;
            run) cmd_run $args ;;
            show)
                case "$args" in
                    modules) cmd_show_modules ;;
                    options) cmd_show_options ;;
                    *) print_error "Usage: show {modules|options}" ;;
                esac
                ;;
            info) cmd_info $args ;;
            search) cmd_search $args ;;
            help) cmd_help $args ;;
            reload) cmd_reload ;;
            clear) cmd_clear ;;
            update) cmd_update ;;
            dashboard) cmd_dashboard ;;
            exit|quit) 
                echo -e "\n${C}${BOLD}Thanks for using SecV! ${STAR}${N}\n"
                exit 0 
                ;;
            "") ;;
            *) 
                print_warning "Unknown command: $cmd ${DIM}(type 'help')${N}"
                ;;
        esac
    done
}

[[ "${BASH_SOURCE[0]}" == "${0}" ]] && main "$@"
