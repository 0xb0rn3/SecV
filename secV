#!/usr/bin/env bash
#
# SecV - Enhanced UI with Real-Time Dashboard
# Version: 2.2.0
#

# Configuration
readonly VERSION="2.2.0"
readonly SECV_HOME="${SECV_HOME:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
readonly TOOLS_DIR="$SECV_HOME/tools"
readonly CACHE_DIR="$SECV_HOME/.cache"
readonly DB_FILE="$CACHE_DIR/modules.db"
readonly UPDATE_CHECK_FILE="$CACHE_DIR/.last_update_check"
readonly DASHBOARD_PY="$SECV_HOME/dashboard.py"

# Dashboard status file
readonly STATUS_FILE="$CACHE_DIR/.module_status"

# Enhanced Colors & Styles
R=$'\e[31m' G=$'\e[32m' Y=$'\e[33m' B=$'\e[34m' C=$'\e[36m' M=$'\e[35m' W=$'\e[97m' N=$'\e[0m'
BOLD=$'\e[1m' DIM=$'\e[2m' ITALIC=$'\e[3m' UNDERLINE=$'\e[4m'

# Symbols
CHECK="‚úì" CROSS="‚úó" ARROW="‚û§" BULLET="‚Ä¢" STAR="‚òÖ" GEAR="‚öô"

# Module registry
declare -a MOD_NAMES MOD_PATHS MOD_CATS MOD_DESCS MOD_EXECS
declare -a PARAM_KEYS PARAM_VALUES
CURRENT_MODULE="" CURRENT_PATH="" CURRENT_EXEC=""
MODULE_COUNT=0

# Dashboard settings
SHOW_DASHBOARD=false
DASHBOARD_PID=""

# ============================================================================
# DASHBOARD FUNCTIONS
# ============================================================================

init_dashboard() {
    # Create dashboard.py if it doesn't exist
    if [[ ! -f "$DASHBOARD_PY" ]]; then
        return 1
    fi
    
    # Initialize status file
    python3 "$DASHBOARD_PY" json > "$STATUS_FILE" 2>/dev/null || true
}

show_dashboard_compact() {
    if [[ -f "$DASHBOARD_PY" ]]; then
        python3 "$DASHBOARD_PY" compact 2>/dev/null || true
    fi
}

show_dashboard_full() {
    if [[ -f "$DASHBOARD_PY" ]]; then
        clear
        python3 "$DASHBOARD_PY" dashboard 2>/dev/null || echo -e "${Y}Dashboard not available${N}"
        echo -e "\n${DIM}Press any key to return...${N}"
        read -n 1 -s
    else
        print_error "Dashboard system not found at: $DASHBOARD_PY"
    fi
}

start_module_tracking() {
    local module_name="$1"
    local target="$2"
    local pid="$3"
    
    if [[ -f "$DASHBOARD_PY" ]]; then
        python3 -c "
import sys
sys.path.insert(0, '$SECV_HOME')
from dashboard import start_module_tracking
start_module_tracking('$module_name', '$target', $pid)
" 2>/dev/null || true
    fi
}

complete_module_tracking() {
    local module_name="$1"
    local success="$2"  # true or false
    local duration="$3"
    
    if [[ -f "$DASHBOARD_PY" ]]; then
        python3 -c "
import sys
sys.path.insert(0, '$SECV_HOME')
from dashboard import complete_module_tracking
complete_module_tracking('$module_name', $success, $duration)
" 2>/dev/null || true
    fi
}

# ============================================================================
# ENHANCED JSON PARSER
# ============================================================================

json_get() {
    local json="$1" key="$2"
    echo "$json" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    keys = '$key'.split('.')
    result = data
    for k in keys:
        result = result.get(k, '')
    print(result if isinstance(result, str) else json.dumps(result))
except:
    pass
" 2>/dev/null
}

json_has_key() {
    local json="$1" key="$2"
    echo "$json" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    keys = '$key'.split('.')
    result = data
    for k in keys:
        if k not in result:
            print('false')
            sys.exit()
        result = result[k]
    print('true')
except:
    print('false')
" 2>/dev/null
}

# ============================================================================
# ENHANCED UI FUNCTIONS
# ============================================================================

print_header() {
    local text="$1"
    local width=67
    echo -e "\n${BOLD}${C}‚ïî$(printf '‚ïê%.0s' $(seq 1 $width))‚ïó${N}"
    echo -e "${BOLD}${C}‚ïë${N} ${BOLD}${W}$text${N}$(printf ' %.0s' $(seq 1 $((width - ${#text}))))${BOLD}${C}‚ïë${N}"
    echo -e "${BOLD}${C}‚ïö$(printf '‚ïê%.0s' $(seq 1 $width))‚ïù${N}"
}

print_success() {
    echo -e "${G}${BOLD}${CHECK}${N} ${G}$1${N}"
}

print_error() {
    echo -e "${R}${BOLD}${CROSS}${N} ${R}$1${N}"
}

print_info() {
    echo -e "${B}${BOLD}${ARROW}${N} ${B}$1${N}"
}

print_warning() {
    echo -e "${Y}${BOLD}‚ö†${N}  ${Y}$1${N}"
}

# ============================================================================
# MODULE MANAGEMENT
# ============================================================================

scan_modules() {
    echo -e "${DIM}Scanning modules...${N}"
    MODULE_COUNT=0
    MOD_NAMES=() MOD_PATHS=() MOD_CATS=() MOD_DESCS=() MOD_EXECS=()
    
    while IFS= read -r -d '' json_file; do
        local dir="${json_file%/*}"
        local json=$(<"$json_file")
        
        local name=$(json_get "$json" "name")
        local cat=$(json_get "$json" "category")
        local desc=$(json_get "$json" "description")
        local exec=$(json_get "$json" "executable")
        
        if [[ -n "$name" ]]; then
            MOD_NAMES+=("$name")
            MOD_PATHS+=("$dir")
            MOD_CATS+=("$cat")
            MOD_DESCS+=("$desc")
            MOD_EXECS+=("$exec")
            ((MODULE_COUNT++))
        fi
    done < <(find "$TOOLS_DIR" -name "module.json" -type f -print0 2>/dev/null)
    
    print_success "Loaded $MODULE_COUNT modules"
}

load_cache() {
    [[ ! -f "$DB_FILE" ]] && return 1
    
    local age=$(($(date +%s) - $(stat -c %Y "$DB_FILE" 2>/dev/null || echo 0)))
    [[ $age -gt 3600 ]] && return 1
    
    MODULE_COUNT=0
    while IFS='|' read -r name path cat desc exec; do
        MOD_NAMES+=("$name")
        MOD_PATHS+=("$path")
        MOD_CATS+=("$cat")
        MOD_DESCS+=("$desc")
        MOD_EXECS+=("$exec")
        ((MODULE_COUNT++))
    done < "$DB_FILE" 2>/dev/null
    
    [[ $MODULE_COUNT -gt 0 ]] && print_success "Loaded $MODULE_COUNT modules from cache"
    return 0
}

# ============================================================================
# EXECUTION ENGINE WITH TRACKING
# ============================================================================

execute_module() {
    local target="$1"
    
    # Build JSON context
    local json="{\"target\":\"$target\",\"params\":{"
    local first=1
    for ((i=0; i<${#PARAM_KEYS[@]}; i++)); do
        [[ $first -eq 0 ]] && json+=","
        json+="\"${PARAM_KEYS[$i]}\":\"${PARAM_VALUES[$i]}\""
        first=0
    done
    json+="}}"
    
    echo -e "\n${BOLD}${C}${GEAR} Executing ${W}$CURRENT_MODULE${C} against ${Y}$target${C}...${N}"
    
    # Get timeout
    local timeout=300
    if [[ -f "$CURRENT_PATH/module.json" ]]; then
        local t=$(json_get "$(<"$CURRENT_PATH/module.json")" "timeout")
        [[ -n "$t" && "$t" != "null" ]] && timeout=$t
    fi
    
    # Execute with tracking
    local start=$(date +%s%N)
    
    cd "$CURRENT_PATH"
    (
        echo "$json" | timeout $timeout bash -c "$CURRENT_EXEC" &
        local exec_pid=$!
        
        # Track module start
        start_module_tracking "$CURRENT_MODULE" "$target" "$exec_pid"
        
        wait $exec_pid
        exit $?
    )
    local ret=$?
    cd - >/dev/null 2>&1
    
    local end=$(date +%s%N)
    local elapsed=$(((end-start)/1000000))
    local elapsed_sec=$(echo "scale=2; $elapsed/1000" | bc)
    
    # Track module completion
    if [[ $ret -eq 0 ]]; then
        complete_module_tracking "$CURRENT_MODULE" "True" "$elapsed_sec"
        print_success "Completed in ${elapsed}ms"
    else
        complete_module_tracking "$CURRENT_MODULE" "False" "$elapsed_sec"
        print_error "Failed after ${elapsed}ms"
    fi
    
    # Show compact dashboard status
    show_dashboard_compact
    
    return $ret
}

# ============================================================================
# MODULE HELP SYSTEM
# ============================================================================

show_module_help() {
    local module_name="$1"
    local module_path=""
    
    for ((i=0; i<MODULE_COUNT; i++)); do
        if [[ "${MOD_NAMES[$i]}" == "$module_name" ]]; then
            module_path="${MOD_PATHS[$i]}"
            break
        fi
    done
    
    if [[ -z "$module_path" ]]; then
        print_error "Module '$module_name' not found"
        return 1
    fi
    
    local json_file="$module_path/module.json"
    if [[ ! -f "$json_file" ]]; then
        print_error "module.json not found for '$module_name'"
        return 1
    fi
    
    # Check if module has built-in help
    local executable="${MOD_EXECS[$i]}"
    if [[ -n "$executable" ]]; then
        cd "$module_path"
        if timeout 2 bash -c "$executable --help 2>/dev/null" 2>/dev/null; then
            cd - >/dev/null
            return 0
        elif timeout 2 bash -c "$executable -h 2>/dev/null" 2>/dev/null; then
            cd - >/dev/null
            return 0
        fi
        cd - >/dev/null
    fi
    
    # Parse and display help from module.json
    local json=$(<"$json_file")
    
    print_header "Module: $module_name"
    
    local desc=$(json_get "$json" "description")
    local author=$(json_get "$json" "author")
    local version=$(json_get "$json" "version")
    local category=$(json_get "$json" "category")
    
    echo -e "\n${BOLD}${DIM}Description:${N} $desc"
    echo -e "${BOLD}${DIM}Author:${N} ${M}$author${N}"
    echo -e "${BOLD}${DIM}Version:${N} ${C}$version${N}"
    echo -e "${BOLD}${DIM}Category:${N} ${Y}$category${N}"
    
    if [[ -f "$module_path/README.md" ]]; then
        echo -e "\n${DIM}${ITALIC}üìñ Detailed documentation: ${UNDERLINE}$module_path/README.md${N}"
    fi
    
    echo
}

# ============================================================================
# ENHANCED COMMANDS
# ============================================================================

cmd_show() {
    case "$1" in
        modules|"")
            print_header "Available Modules ($MODULE_COUNT)"
            local last_cat=""
            for ((i=0; i<MODULE_COUNT; i++)); do
                if [[ "${MOD_CATS[$i]}" != "$last_cat" ]]; then
                    echo -e "\n${BOLD}${Y}[${MOD_CATS[$i]}]${N}"
                    last_cat="${MOD_CATS[$i]}"
                fi
                printf "  ${BOLD}${C}%-20s${N} ${DIM}‚îÇ${N} %s\n" "${MOD_NAMES[$i]}" "${MOD_DESCS[$i]}"
            done | sort
            echo
            ;;
        categories)
            print_header "Module Categories"
            printf '%s\n' "${MOD_CATS[@]}" | sort -u | while read cat; do
                local count=$(printf '%s\n' "${MOD_CATS[@]}" | grep -c "^$cat$")
                printf "  ${BOLD}${Y}%-20s${N} ${DIM}‚Üí${N} ${G}%d modules${N}\n" "$cat" "$count"
            done
            echo
            ;;
        options)
            if [[ -z "$CURRENT_MODULE" ]]; then
                print_warning "No module loaded"
            else
                print_header "Module Configuration"
                echo -e "\n${BOLD}${C}Current Module:${N} ${W}$CURRENT_MODULE${N}"
                echo -e "\n${BOLD}${Y}Parameters:${N}"
                if [[ ${#PARAM_KEYS[@]} -eq 0 ]]; then
                    echo -e "  ${DIM}No parameters set${N}"
                else
                    for ((i=0; i<${#PARAM_KEYS[@]}; i++)); do
                        printf "  ${BOLD}${C}%-15s${N} ${DIM}‚Üí${N} ${G}%s${N}\n" "${PARAM_KEYS[$i]}" "${PARAM_VALUES[$i]}"
                    done
                fi
            fi
            echo
            ;;
        status|dashboard)
            show_dashboard_full
            ;;
    esac
}

cmd_use() {
    local module="$1"
    
    for ((i=0; i<MODULE_COUNT; i++)); do
        if [[ "${MOD_NAMES[$i]}" == "$module" ]]; then
            CURRENT_MODULE="$module"
            CURRENT_PATH="${MOD_PATHS[$i]}"
            CURRENT_EXEC="${MOD_EXECS[$i]}"
            PARAM_KEYS=() PARAM_VALUES=()
            
            print_success "Loaded: ${BOLD}$module${N}"
            echo -e "  ${DIM}Category:${N} ${Y}${MOD_CATS[$i]}${N}"
            echo -e "  ${DIM}Path:${N} ${B}$CURRENT_PATH${N}"
            echo -e "\n${C}${ITALIC}Type '${BOLD}help module${N}${C}${ITALIC}' for detailed usage${N}"
            return 0
        fi
    done
    
    print_error "Module '$module' not found"
    return 1
}

cmd_set() {
    [[ -z "$CURRENT_MODULE" ]] && print_warning "No module loaded" && return
    
    local key="$1" value="$2"
    local found=0
    
    for ((i=0; i<${#PARAM_KEYS[@]}; i++)); do
        if [[ "${PARAM_KEYS[$i]}" == "$key" ]]; then
            PARAM_VALUES[$i]="$value"
            found=1
            break
        fi
    done
    
    [[ $found -eq 0 ]] && PARAM_KEYS+=("$key") && PARAM_VALUES+=("$value")
    echo -e "${G}${BOLD}$key${N} ${DIM}‚Üí${N} ${C}$value${N}"
}

cmd_run() {
    [[ -z "$CURRENT_MODULE" ]] && print_warning "No module loaded" && return
    [[ -z "$1" ]] && print_error "Target required" && return
    
    execute_module "$1"
}

cmd_search() {
    local query="$1"
    print_header "Search: '$query'"
    
    local found=0
    for ((i=0; i<MODULE_COUNT; i++)); do
        if [[ "${MOD_NAMES[$i]}" == *"$query"* ]] || \
           [[ "${MOD_DESCS[$i]}" == *"$query"* ]] || \
           [[ "${MOD_CATS[$i]}" == *"$query"* ]]; then
            printf "  ${BOLD}${C}%-20s${N} ${DIM}[${Y}%s${DIM}]${N} %s\n" \
                "${MOD_NAMES[$i]}" "${MOD_CATS[$i]}" "${MOD_DESCS[$i]}"
            ((found++))
        fi
    done
    
    echo -e "\n${DIM}Found $found matching modules${N}\n"
}

cmd_info() {
    local module="${1:-$CURRENT_MODULE}"
    
    if [[ -z "$module" ]]; then
        print_warning "No module specified or loaded"
        return 1
    fi
    
    show_module_help "$module"
}

cmd_help() {
    local subcmd="$1"
    
    case "$subcmd" in
        module|modules)
            if [[ -n "$CURRENT_MODULE" ]]; then
                show_module_help "$CURRENT_MODULE"
            else
                print_warning "No module loaded. Use 'help module <name>' or load a module first"
            fi
            ;;
        "")
            print_header "SecV Command Reference"
            cat << 'HELP'

CORE COMMANDS:
  show [modules|categories|options|dashboard]
      List modules, categories, configuration, or show dashboard
  
  use <module>
      Load a security module
  
  set <key> <value>
      Configure module parameters
  
  run <target>
      Execute loaded module against target
  
  info [module]
      Display detailed module information
  
  help module [name]
      Show comprehensive module help
  
  search <query>
      Search modules by name, category, or description
  
  dashboard
      Show real-time module status dashboard
  
  back
      Unload current module
  
  reload
      Rescan module directory
  
  update
      Check for and install updates
  
  autoupdate
      Toggle automatic update checks
  
  clear
      Clear terminal screen
  
  exit | quit
      Exit SecV shell

DASHBOARD COMMANDS:
  show dashboard      Full dashboard view
  show status         Same as 'show dashboard'
  dashboard           Quick access to dashboard
  
  The dashboard shows:
    ‚Ä¢ Active running modules with runtime
    ‚Ä¢ Recently completed modules
    ‚Ä¢ Recent failures with duration
    ‚Ä¢ Real-time statistics

QUICK START:
  1. Browse modules:    show modules
  2. Load module:       use portscan
  3. View help:         help module
  4. Configure:         set ports web
  5. Execute:           run example.com
  6. Check status:      dashboard

HELP
            echo
            ;;
        *)
            print_warning "Unknown help topic. Try: help, help module"
            ;;
    esac
}

cmd_update() {
    if [[ -f "$SECV_HOME/update.py" ]]; then
        python3 "$SECV_HOME/update.py"
    else
        print_error "Updater not found at: $SECV_HOME/update.py"
    fi
}

cmd_no_auto_update() {
    if [[ -f "$CACHE_DIR/.no_auto_update" ]]; then
        rm -f "$CACHE_DIR/.no_auto_update"
        print_success "Auto-update enabled"
        echo -e "${DIM}SecV will check for updates every 24 hours${N}"
    else
        touch "$CACHE_DIR/.no_auto_update"
        print_warning "Auto-update disabled"
        echo -e "${DIM}Use 'update' command to manually check for updates${N}"
    fi
}

# ============================================================================
# UPDATE CHECK
# ============================================================================

should_check_updates() {
    [[ -f "$CACHE_DIR/.no_auto_update" ]] && return 1
    [[ ! -d "$SECV_HOME/.git" ]] && return 1
    
    if [[ -f "$UPDATE_CHECK_FILE" ]]; then
        local last_check=$(cat "$UPDATE_CHECK_FILE" 2>/dev/null || echo 0)
        local now=$(date +%s)
        local age=$((now - last_check))
        [[ $age -lt 86400 ]] && return 1
    fi
    
    return 0
}

if should_check_updates; then
    if [[ -f "$SECV_HOME/update.py" ]]; then
        python3 "$SECV_HOME/update.py" 2>/dev/null
        echo "$(date +%s)" > "$UPDATE_CHECK_FILE"
    fi
fi

# ============================================================================
# MAIN
# ============================================================================

main() {
    mkdir -p "$CACHE_DIR" "$TOOLS_DIR"
    
    # Initialize dashboard
    init_dashboard
    
    # Enhanced Banner
    clear
    echo -e "${BOLD}${C}"
    cat << 'BANNER'
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó                             ‚ïë
‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë                             ‚ïë
‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë                             ‚ïë
‚ïë   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë     ‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù                             ‚ïë
‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù                              ‚ïë
‚ïë   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù                               ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
BANNER
    echo -e "${N}"
    echo -e "${DIM}   SecV v$VERSION - Real-Time Module Status Dashboard${N}"
    echo -e "${DIM}   The Polyglot Cybersecurity Orchestration Platform${N}\n"
    
    load_cache || scan_modules
    
    echo -e "${DIM}${ITALIC}Type '${BOLD}help${N}${DIM}${ITALIC}' for commands, '${BOLD}dashboard${N}${DIM}${ITALIC}' for status${N}\n"
    
    # Command loop with enhanced prompt
    while true; do
        # Show compact status if dashboard available
        if [[ -f "$DASHBOARD_PY" ]] && [[ -z "$CURRENT_MODULE" ]]; then
            show_dashboard_compact
        fi
        
        if [[ -n "$CURRENT_MODULE" ]]; then
            printf "${BOLD}${G}secV${N} ${BOLD}${R}(${CURRENT_MODULE})${N} ${C}${ARROW}${N} "
        else
            printf "${BOLD}${G}secV${N} ${C}${ARROW}${N} "
        fi
        
        read -r cmd args
        
        case "$cmd" in
            show) cmd_show $args ;;
            use) cmd_use $args ;;
            set) cmd_set $args ;;
            run) cmd_run $args ;;
            search) cmd_search "$args" ;;
            info) cmd_info $args ;;
            help) cmd_help $args ;;
            update) cmd_update ;;
            autoupdate) cmd_no_auto_update ;;
            dashboard|status) show_dashboard_full ;;
            back)
                CURRENT_MODULE="" CURRENT_PATH="" CURRENT_EXEC=""
                PARAM_KEYS=() PARAM_VALUES=()
                print_info "Module unloaded"
                ;;
            reload)
                rm -f "$DB_FILE"
                scan_modules
                ;;
            clear) clear ;;
            exit|quit) 
                echo -e "\n${C}${BOLD}Thanks for using SecV! Stay ethical. ${STAR}${N}\n"
                exit 0 
                ;;
            "") ;;
            *) print_warning "Unknown command: $cmd ${DIM}(type 'help')${N}" ;;
        esac
    done
}

[[ "${BASH_SOURCE[0]}" == "${0}" ]] && main "$@"
