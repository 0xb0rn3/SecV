#!/usr/bin/env bash
#
# SecV - Unified Security Toolkit Platform
# Single-file implementation with optional C core acceleration
#

# Configuration
readonly VERSION="2.0.0"
readonly SECV_HOME="${SECV_HOME:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)}"
readonly TOOLS_DIR="$SECV_HOME/tools"
readonly CACHE_DIR="$SECV_HOME/.cache"
readonly CORE_BIN="$CACHE_DIR/core"
readonly DB_FILE="$CACHE_DIR/modules.db"
readonly WORKFLOW_DIR="$SECV_HOME/workflows"

# Performance settings
set -o noglob 2>/dev/null
export LC_ALL=C
ulimit -n 65535 2>/dev/null  # More file descriptors for parallel ops

# Terminal colors
R=$'\e[31m' G=$'\e[32m' Y=$'\e[33m' B=$'\e[34m' C=$'\e[36m' N=$'\e[0m' BOLD=$'\e[1m'

# Module registry (works on Bash 3+)
declare -a MOD_NAMES MOD_PATHS MOD_CATS MOD_DESCS MOD_EXECS
declare -a PARAM_KEYS PARAM_VALUES
CURRENT_MODULE="" CURRENT_PATH="" CURRENT_EXEC=""
MODULE_COUNT=0

# Workflow state
declare -a WORKFLOW_STEPS WORKFLOW_RESULTS
WORKFLOW_MODE=0

# ============================================================================
# CORE ENGINE BUILDER
# ============================================================================

build_core() {
    [[ -f "$CORE_BIN" ]] && return 0
    
    mkdir -p "$CACHE_DIR"
    local src="$CACHE_DIR/core.c"
    
    cat > "$src" << 'CORE_C'
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <signal.h>
#include <time.h>

// Fast JSON field extraction
void json_extract(const char *json, const char *key, char *out, size_t max) {
    char pattern[256];
    snprintf(pattern, sizeof(pattern), "\"%s\"", key);
    char *pos = strstr(json, pattern);
    if (!pos) { out[0] = 0; return; }
    
    pos = strchr(pos, ':');
    if (!pos) { out[0] = 0; return; }
    
    pos++;
    while (*pos == ' ' || *pos == '\t' || *pos == '\n') pos++;
    
    if (*pos == '"') {
        pos++;
        char *end = strchr(pos, '"');
        if (end) {
            size_t len = end - pos;
            if (len >= max) len = max - 1;
            memcpy(out, pos, len);
            out[len] = 0;
        }
    } else {
        char *end = pos;
        while (*end && *end != ',' && *end != '}' && *end != '\n') end++;
        size_t len = end - pos;
        if (len >= max) len = max - 1;
        memcpy(out, pos, len);
        out[len] = 0;
    }
}

// Module scanner
void scan_modules(const char *dir, int depth) {
    if (depth > 10) return;
    
    DIR *d = opendir(dir);
    if (!d) return;
    
    struct dirent *ent;
    char path[4096], json_path[4096];
    
    while ((ent = readdir(d))) {
        if (ent->d_name[0] == '.') continue;
        
        snprintf(path, sizeof(path), "%s/%s", dir, ent->d_name);
        
        if (strcmp(ent->d_name, "module.json") == 0) {
            FILE *f = fopen(path, "r");
            if (f) {
                char json[8192];
                fread(json, 1, sizeof(json)-1, f);
                fclose(f);
                
                char name[256], cat[256], desc[512], exec[512];
                json_extract(json, "name", name, sizeof(name));
                json_extract(json, "category", cat, sizeof(cat));
                json_extract(json, "description", desc, sizeof(desc));
                json_extract(json, "executable", exec, sizeof(exec));
                
                if (name[0]) {
                    printf("%s|%s|%s|%s|%s\n", name, dir, cat, desc, exec);
                }
            }
        } else {
            struct stat st;
            if (stat(path, &st) == 0 && S_ISDIR(st.st_mode)) {
                scan_modules(path, depth + 1);
            }
        }
    }
    closedir(d);
}

// Execute with timeout
int execute(const char *cmd, const char *input, int timeout) {
    int pipes[2];
    pipe(pipes);
    
    pid_t pid = fork();
    if (pid == 0) {
        close(pipes[1]);
        dup2(pipes[0], 0);
        execl("/bin/sh", "sh", "-c", cmd, NULL);
        exit(1);
    }
    
    close(pipes[0]);
    write(pipes[1], input, strlen(input));
    close(pipes[1]);
    
    alarm(timeout);
    int status;
    waitpid(pid, &status, 0);
    alarm(0);
    
    return WEXITSTATUS(status);
}

int main(int argc, char **argv) {
    if (argc < 2) return 1;
    
    if (strcmp(argv[1], "scan") == 0) {
        scan_modules(argc > 2 ? argv[2] : "tools", 0);
    } else if (strcmp(argv[1], "exec") == 0 && argc > 4) {
        return execute(argv[2], argv[3], atoi(argv[4]));
    } else if (strcmp(argv[1], "json") == 0 && argc > 3) {
        char out[1024];
        json_extract(argv[2], argv[3], out, sizeof(out));
        printf("%s\n", out);
    }
    
    return 0;
}
CORE_C
    
    # Try compiling
    for cc in gcc clang tcc cc; do
        command -v "$cc" >/dev/null 2>&1 && \
            "$cc" -O3 -o "$CORE_BIN" "$src" 2>/dev/null && \
            rm "$src" && return 0
    done
    
    rm -f "$src" "$CORE_BIN"
    return 1
}

# ============================================================================
# MODULE MANAGEMENT
# ============================================================================

# JSON extractor (bash fallback)
json_get() {
    local json="$1" key="$2"
    if [[ -x "$CORE_BIN" ]]; then
        "$CORE_BIN" json "$json" "$key"
    else
        echo "$json" | grep -oP "\"$key\"\\s*:\\s*\"\\K[^\"]*" 2>/dev/null || \
        echo "$json" | sed -n "s/.*\"$key\"[[:space:]]*:[[:space:]]*\"\([^\"]*\)\".*/\1/p"
    fi
}

# Scan for modules
scan_modules() {
    echo -e "${Y}Scanning modules...${N}"
    MODULE_COUNT=0
    MOD_NAMES=() MOD_PATHS=() MOD_CATS=() MOD_DESCS=() MOD_EXECS=()
    
    if [[ -x "$CORE_BIN" ]]; then
        # Fast C scanning
        while IFS='|' read -r name path cat desc exec; do
            MOD_NAMES+=("$name")
            MOD_PATHS+=("$path")
            MOD_CATS+=("$cat")
            MOD_DESCS+=("$desc")
            MOD_EXECS+=("$exec")
            ((MODULE_COUNT++))
        done < <("$CORE_BIN" scan "$TOOLS_DIR")
    else
        # Bash fallback
        while IFS= read -r -d '' json_file; do
            local dir="${json_file%/*}"
            local json=$(<"$json_file")
            
            local name=$(json_get "$json" "name")
            local cat=$(json_get "$json" "category")
            local desc=$(json_get "$json" "description")
            local exec=$(json_get "$json" "executable")
            
            if [[ -n "$name" ]]; then
                MOD_NAMES+=("$name")
                MOD_PATHS+=("$dir")
                MOD_CATS+=("$cat")
                MOD_DESCS+=("$desc")
                MOD_EXECS+=("$exec")
                ((MODULE_COUNT++))
            fi
        done < <(find "$TOOLS_DIR" -name "module.json" -type f -print0 2>/dev/null)
    fi
    
    # Save to cache
    {
        for ((i=0; i<MODULE_COUNT; i++)); do
            echo "${MOD_NAMES[$i]}|${MOD_PATHS[$i]}|${MOD_CATS[$i]}|${MOD_DESCS[$i]}|${MOD_EXECS[$i]}"
        done
    } > "$DB_FILE"
    
    echo -e "${G}✓ Loaded $MODULE_COUNT modules${N}"
}

# Load from cache
load_cache() {
    [[ ! -f "$DB_FILE" ]] && return 1
    
    local age=$(($(date +%s) - $(stat -c %Y "$DB_FILE" 2>/dev/null || echo 0)))
    [[ $age -gt 3600 ]] && return 1
    
    MODULE_COUNT=0
    while IFS='|' read -r name path cat desc exec; do
        MOD_NAMES+=("$name")
        MOD_PATHS+=("$path")
        MOD_CATS+=("$cat")
        MOD_DESCS+=("$desc")
        MOD_EXECS+=("$exec")
        ((MODULE_COUNT++))
    done < "$DB_FILE"
    
    echo -e "${G}✓ Loaded $MODULE_COUNT modules from cache${N}"
    return 0
}

# Wrap industry tools
wrap_tool() {
    local tool="$1"
    local wrapper_dir="$TOOLS_DIR/wrapped"
    mkdir -p "$wrapper_dir"
    
    case "$tool" in
        nmap)
            cat > "$wrapper_dir/nmap/module.json" << EOF
{
    "name": "nmap",
    "category": "scanning",
    "description": "Network mapper - industry standard port scanner",
    "executable": "nmap",
    "timeout": 600
}
EOF
            ;;
        metasploit|msfconsole)
            cat > "$wrapper_dir/metasploit/module.json" << EOF
{
    "name": "metasploit",
    "category": "exploitation",
    "description": "Metasploit Framework integration",
    "executable": "bash -c 'echo \"use \\\$MSF_MODULE; set RHOSTS \\\$(echo \\\$1 | jq -r .target); run\" | msfconsole -q -x -'",
    "timeout": 1800
}
EOF
            ;;
        sqlmap)
            cat > "$wrapper_dir/sqlmap/module.json" << EOF
{
    "name": "sqlmap",
    "category": "web",
    "description": "SQL injection detection and exploitation",
    "executable": "sqlmap -u",
    "timeout": 900
}
EOF
            ;;
        nikto)
            cat > "$wrapper_dir/nikto/module.json" << EOF
{
    "name": "nikto",
    "category": "web",
    "description": "Web server scanner",
    "executable": "nikto -h",
    "timeout": 600
}
EOF
            ;;
    esac
}

# ============================================================================
# EXECUTION ENGINE
# ============================================================================

execute_module() {
    local target="$1"
    shift
    
    # Build JSON context
    local json="{\"target\":\"$target\",\"params\":{"
    local first=1
    for ((i=0; i<${#PARAM_KEYS[@]}; i++)); do
        [[ $first -eq 0 ]] && json+=","
        json+="\"${PARAM_KEYS[$i]}\":\"${PARAM_VALUES[$i]}\""
        first=0
    done
    json+="}}"
    
    echo -e "${Y}⚙ Executing $CURRENT_MODULE against $target...${N}"
    
    # Get timeout
    local timeout=300
    if [[ -f "$CURRENT_PATH/module.json" ]]; then
        local t=$(json_get "$(<"$CURRENT_PATH/module.json")" "timeout")
        [[ -n "$t" ]] && timeout=$t
    fi
    
    # Execute
    local start=$(date +%s%N)
    
    cd "$CURRENT_PATH"
    if [[ -x "$CORE_BIN" ]]; then
        echo "$json" | timeout $timeout $CURRENT_EXEC
    else
        echo "$json" | timeout $timeout bash -c "$CURRENT_EXEC"
    fi
    local ret=$?
    cd - >/dev/null
    
    local end=$(date +%s%N)
    local elapsed=$(((end-start)/1000000))
    
    [[ $ret -eq 0 ]] && echo -e "${G}✓ Success (${elapsed}ms)${N}" || echo -e "${R}✗ Failed (${elapsed}ms)${N}"
    
    # Store for workflows
    if [[ $WORKFLOW_MODE -eq 1 ]]; then
        WORKFLOW_RESULTS+=("$CURRENT_MODULE:$ret:$elapsed")
    fi
    
    return $ret
}

# ============================================================================
# WORKFLOW ENGINE
# ============================================================================

workflow_add() {
    local step="$1"
    WORKFLOW_STEPS+=("$step")
    echo -e "${G}Added to workflow: $step${N}"
}

workflow_run() {
    echo -e "${C}${BOLD}Executing Workflow (${#WORKFLOW_STEPS[@]} steps)${N}"
    WORKFLOW_MODE=1
    
    for step in "${WORKFLOW_STEPS[@]}"; do
        echo -e "${B}Step: $step${N}"
        eval "$step"
    done
    
    WORKFLOW_MODE=0
    echo -e "${G}Workflow complete${N}"
}

# ============================================================================
# COMMANDS
# ============================================================================

cmd_show() {
    case "$1" in
        modules|"")
            echo -e "\n${C}${BOLD}Modules ($MODULE_COUNT total)${N}"
            local last_cat=""
            for ((i=0; i<MODULE_COUNT; i++)); do
                if [[ "${MOD_CATS[$i]}" != "$last_cat" ]]; then
                    echo -e "\n${Y}[${MOD_CATS[$i]}]${N}"
                    last_cat="${MOD_CATS[$i]}"
                fi
                printf "  ${G}%-20s${N} - %s\n" "${MOD_NAMES[$i]}" "${MOD_DESCS[$i]}"
            done | sort
            ;;
        categories)
            echo -e "\n${C}${BOLD}Categories${N}"
            printf '%s\n' "${MOD_CATS[@]}" | sort -u | while read cat; do
                local count=$(printf '%s\n' "${MOD_CATS[@]}" | grep -c "^$cat$")
                printf "  ${G}%-20s${N} : %d modules\n" "$cat" "$count"
            done
            ;;
    esac
    echo
}

cmd_use() {
    local module="$1"
    
    for ((i=0; i<MODULE_COUNT; i++)); do
        if [[ "${MOD_NAMES[$i]}" == "$module" ]]; then
            CURRENT_MODULE="$module"
            CURRENT_PATH="${MOD_PATHS[$i]}"
            CURRENT_EXEC="${MOD_EXECS[$i]}"
            PARAM_KEYS=() PARAM_VALUES=()
            
            echo -e "${G}✓ Loaded: $module${N}"
            echo -e "  Category: ${MOD_CATS[$i]}"
            echo -e "  Path: $CURRENT_PATH"
            return 0
        fi
    done
    
    echo -e "${R}Module '$module' not found${N}"
    return 1
}

cmd_set() {
    [[ -z "$CURRENT_MODULE" ]] && echo -e "${Y}No module loaded${N}" && return
    
    local key="$1" value="$2"
    local found=0
    
    for ((i=0; i<${#PARAM_KEYS[@]}; i++)); do
        if [[ "${PARAM_KEYS[$i]}" == "$key" ]]; then
            PARAM_VALUES[$i]="$value"
            found=1
            break
        fi
    done
    
    [[ $found -eq 0 ]] && PARAM_KEYS+=("$key") && PARAM_VALUES+=("$value")
    echo -e "${G}$key => $value${N}"
}

cmd_run() {
    [[ -z "$CURRENT_MODULE" ]] && echo -e "${Y}No module loaded${N}" && return
    [[ -z "$1" ]] && echo -e "${R}Target required${N}" && return
    
    execute_module "$1"
}

cmd_search() {
    local query="$1"
    echo -e "\n${C}Search: '$query'${N}"
    
    for ((i=0; i<MODULE_COUNT; i++)); do
        if [[ "${MOD_NAMES[$i]}" == *"$query"* ]] || \
           [[ "${MOD_DESCS[$i]}" == *"$query"* ]] || \
           [[ "${MOD_CATS[$i]}" == *"$query"* ]]; then
            printf "  ${G}%-20s${N} [${Y}%s${N}] - %s\n" \
                "${MOD_NAMES[$i]}" "${MOD_CATS[$i]}" "${MOD_DESCS[$i]}"
        fi
    done
    echo
}

cmd_chain() {
    # Chain multiple modules: chain portscan,vuln-check,report
    IFS=',' read -ra modules <<< "$1"
    local target="$2"
    
    echo -e "${C}${BOLD}Chaining ${#modules[@]} modules${N}"
    
    for mod in "${modules[@]}"; do
        cmd_use "$mod"
        [[ $? -eq 0 ]] && execute_module "$target"
    done
}

cmd_parallel() {
    # Run module against multiple targets in parallel
    local targets="$1"
    [[ -z "$CURRENT_MODULE" ]] && echo -e "${Y}No module loaded${N}" && return
    
    echo -e "${C}${BOLD}Parallel execution${N}"
    
    for target in $targets; do
        execute_module "$target" &
    done
    
    wait
    echo -e "${G}All parallel jobs complete${N}"
}

# ============================================================================
# MAIN
# ============================================================================

main() {
    # Setup
    mkdir -p "$CACHE_DIR" "$TOOLS_DIR" "$WORKFLOW_DIR"
    
    # Try building C core
    build_core && echo -e "${G}✓ C core acceleration available${N}"
    
    # Banner
    echo -e "${C}╔═══════════════════════════════════════════════════════════════════╗"
    echo "║   ███████╗███████╗ ██████╗██╗   ██╗                             ║"
    echo "║   ██╔════╝██╔════╝██╔════╝██║   ██║                             ║"
    echo "║   ███████╗█████╗  ██║     ██║   ██║                             ║"
    echo "║   ╚════██║██╔══╝  ██║     ╚██╗ ██╔╝                             ║"
    echo "║   ███████║███████╗╚██████╗ ╚████╔╝                              ║"
    echo "║   ╚══════╝╚══════╝ ╚═════╝  ╚═══╝                               ║"
    echo "║                                                                   ║"
    echo "║   Unified Security Platform v$VERSION                               ║"
    echo "╚═══════════════════════════════════════════════════════════════════╝${N}"
    
    # Load modules
    load_cache || scan_modules
    
    # Wrap common tools if found
    for tool in nmap metasploit sqlmap nikto; do
        command -v "$tool" >/dev/null 2>&1 && wrap_tool "$tool"
    done
    
    echo -e "${C}Type 'help' for commands${N}\n"
    
    # Command loop
    while true; do
        # Prompt
        if [[ -n "$CURRENT_MODULE" ]]; then
            printf "${G}secV ${R}($CURRENT_MODULE)${N} > "
        else
            printf "${G}secV${N} > "
        fi
        
        read -r cmd args
        
        case "$cmd" in
            show) cmd_show $args ;;
            use) cmd_use $args ;;
            set) cmd_set $args ;;
            run) cmd_run $args ;;
            search) cmd_search "$args" ;;
            chain) cmd_chain $args ;;
            parallel) cmd_parallel "$args" ;;
            workflow)
                case "$args" in
                    add*) workflow_add "${args#add }" ;;
                    run) workflow_run ;;
                    clear) WORKFLOW_STEPS=() && echo "Workflow cleared" ;;
                    *) echo "workflow [add <cmd>|run|clear]" ;;
                esac
                ;;
            back)
                CURRENT_MODULE="" CURRENT_PATH="" CURRENT_EXEC=""
                PARAM_KEYS=() PARAM_VALUES=()
                ;;
            reload)
                rm -f "$DB_FILE"
                scan_modules
                ;;
            wrap)
                wrap_tool "$args"
                reload
                ;;
            help)
                cat << HELP

${C}${BOLD}Core Commands:${N}
  show [modules|categories]  List modules/categories
  use <module>              Load module
  set <key> <value>         Set parameter
  run <target>              Execute module
  search <query>            Search modules
  back                      Unload module

${C}${BOLD}Advanced:${N}
  chain <mod1,mod2> <target>  Chain modules
  parallel <targets>          Run parallel
  workflow add <cmd>          Add to workflow
  workflow run                Execute workflow
  wrap <tool>                 Wrap external tool

${C}${BOLD}Examples:${N}
  use nmap
  run scanme.nmap.org
  
  chain portscan,vulnscan 192.168.1.1
  
  workflow add use portscan
  workflow add run \$TARGET
  workflow run

HELP
                ;;
            clear) clear ;;
            exit|quit) echo -e "${C}Goodbye!${N}" && exit 0 ;;
            "") ;;
            *) echo "Unknown command: $cmd" ;;
        esac
    done
}

# Run if not sourced
[[ "${BASH_SOURCE[0]}" == "${0}" ]] && main "$@"
