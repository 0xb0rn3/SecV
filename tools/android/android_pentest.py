#!/usr/bin/env python3
"""
Android Penetration Testing Module for SecV v1.0
Author: SecVulnHub Team | Enhanced by 0xb0rn3
Category: Mobile Security

Complete Android security testing suite with:
  • Device reconnaissance & fingerprinting
  • Application security analysis
  • Network traffic interception
  • Privilege escalation testing
  • Data exfiltration simulation
  • Vulnerability scanning
  • Forensics & artifact extraction
  • Root detection bypass
  • SSL pinning bypass
  • Frida integration
  • Automated exploit chains
"""

import json
import sys
import subprocess
import os
import re
import time
import socket
import hashlib
import base64
import tempfile
import shutil
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict, field

# ============================================================================
# DEPENDENCY MANAGEMENT
# ============================================================================

CAPABILITIES = {"basic": True}

try:
    import xml.etree.ElementTree as ET
    CAPABILITIES["xml"] = True
except ImportError:
    CAPABILITIES["xml"] = False

try:
    import zipfile
    CAPABILITIES["zipfile"] = True
except ImportError:
    CAPABILITIES["zipfile"] = False

# Optional dependencies
try:
    import requests
    requests.packages.urllib3.disable_warnings()
    CAPABILITIES["requests"] = True
except ImportError:
    CAPABILITIES["requests"] = False

try:
    from cryptography import x509
    from cryptography.hazmat.backends import default_backend
    CAPABILITIES["crypto"] = True
except ImportError:
    CAPABILITIES["crypto"] = False

# ============================================================================
# ANDROID SECURITY CONSTANTS
# ============================================================================

# Dangerous Android permissions
DANGEROUS_PERMISSIONS = [
    "android.permission.READ_CALENDAR",
    "android.permission.WRITE_CALENDAR",
    "android.permission.CAMERA",
    "android.permission.READ_CONTACTS",
    "android.permission.WRITE_CONTACTS",
    "android.permission.GET_ACCOUNTS",
    "android.permission.ACCESS_FINE_LOCATION",
    "android.permission.ACCESS_COARSE_LOCATION",
    "android.permission.RECORD_AUDIO",
    "android.permission.READ_PHONE_STATE",
    "android.permission.READ_PHONE_NUMBERS",
    "android.permission.CALL_PHONE",
    "android.permission.READ_CALL_LOG",
    "android.permission.WRITE_CALL_LOG",
    "android.permission.ADD_VOICEMAIL",
    "android.permission.USE_SIP",
    "android.permission.PROCESS_OUTGOING_CALLS",
    "android.permission.BODY_SENSORS",
    "android.permission.SEND_SMS",
    "android.permission.RECEIVE_SMS",
    "android.permission.READ_SMS",
    "android.permission.RECEIVE_WAP_PUSH",
    "android.permission.RECEIVE_MMS",
    "android.permission.READ_EXTERNAL_STORAGE",
    "android.permission.WRITE_EXTERNAL_STORAGE",
    "android.permission.ACCESS_MEDIA_LOCATION",
]

# Critical security flags
SECURITY_FLAGS = [
    "android:debuggable",
    "android:allowBackup",
    "android:usesCleartextTraffic",
    "android:networkSecurityConfig",
    "android:exported",
    "android:permission",
]

# Common vulnerability patterns
VULN_PATTERNS = {
    "SQL_INJECTION": [
        r"execSQL\s*\(",
        r"rawQuery\s*\(",
        r"query\s*\(",
    ],
    "HARDCODED_SECRETS": [
        r"password\s*=\s*['\"][\w]+['\"]",
        r"api[_-]?key\s*=\s*['\"][\w]+['\"]",
        r"secret\s*=\s*['\"][\w]+['\"]",
        r"token\s*=\s*['\"][\w]+['\"]",
    ],
    "INSECURE_CRYPTO": [
        r"DES",
        r"MD5",
        r"SHA1",
        r"ECB",
    ],
    "WEBVIEW_VULNS": [
        r"setJavaScriptEnabled\s*\(\s*true\s*\)",
        r"addJavascriptInterface",
        r"loadUrl\s*\(",
    ],
    "INTENT_VULNS": [
        r"getIntent\s*\(\s*\)",
        r"getStringExtra",
        r"getParcelableExtra",
    ],
}

# Known vulnerable apps database
KNOWN_VULNS = {
    "com.android.insecurebankv2": {
        "name": "InsecureBank v2",
        "vulns": ["SQL Injection", "Weak Crypto", "Intent Hijacking"],
        "severity": "CRITICAL"
    },
    "com.mwr.dz": {
        "name": "Drozer Agent",
        "vulns": ["Debuggable", "Exported Components"],
        "severity": "HIGH"
    },
}

# ============================================================================
# DATA STRUCTURES
# ============================================================================

@dataclass
class AndroidDevice:
    """Android device information"""
    serial: str
    model: str = ""
    manufacturer: str = ""
    android_version: str = ""
    sdk_version: str = ""
    architecture: str = ""
    state: str = ""
    rooted: bool = False
    selinux_status: str = ""
    encryption_status: str = ""
    screen_lock: bool = False
    developer_mode: bool = False
    usb_debugging: bool = False
    adb_over_network: bool = False
    battery_level: int = 0
    uptime: str = ""
    kernel_version: str = ""
    build_id: str = ""
    security_patch: str = ""
    bootloader_unlocked: bool = False

@dataclass
class AppSecurityProfile:
    """Application security analysis"""
    package_name: str
    app_name: str = ""
    version_name: str = ""
    version_code: str = ""
    min_sdk: str = ""
    target_sdk: str = ""
    
    # Security flags
    debuggable: bool = False
    allow_backup: bool = False
    cleartext_traffic: bool = False
    has_network_security_config: bool = False
    
    # Permissions
    permissions: List[str] = field(default_factory=list)
    dangerous_permissions: List[str] = field(default_factory=list)
    custom_permissions: List[str] = field(default_factory=list)
    
    # Components
    activities: int = 0
    services: int = 0
    receivers: int = 0
    providers: int = 0
    exported_activities: int = 0
    exported_services: int = 0
    exported_receivers: int = 0
    exported_providers: int = 0
    
    # Vulnerabilities
    vulnerabilities: List[Dict] = field(default_factory=list)
    security_score: int = 100
    risk_level: str = "LOW"
    
    # File analysis
    native_libraries: List[str] = field(default_factory=list)
    has_obfuscation: bool = False
    certificate_info: Dict = field(default_factory=dict)
    
    # Runtime info
    install_location: str = ""
    data_directory: str = ""
    uid: str = ""

@dataclass
class NetworkCapture:
    """Network traffic capture info"""
    package_name: str
    capture_file: str = ""
    duration: int = 0
    packets_captured: int = 0
    http_requests: int = 0
    https_requests: int = 0
    dns_queries: int = 0
    domains_contacted: List[str] = field(default_factory=list)
    ips_contacted: List[str] = field(default_factory=list)
    insecure_connections: List[Dict] = field(default_factory=list)
    leaked_data: List[Dict] = field(default_factory=list)

# ============================================================================
# ANDROID PENTEST ENGINE
# ============================================================================

class AndroidPentester:
    """Complete Android penetration testing suite"""
    
    def __init__(self, context: Dict):
        self.context = context
        self.target = context.get('target', 'localhost')
        self.params = context.get('params', {})
        
        # Operation mode
        self.operation = self.params.get('operation', 'recon').lower()
        self.serial = self.params.get('device', '')
        self.package = self.params.get('package', '')
        
        # Advanced options (HacknDroid features)
        self.enable_frida = self.params.get('frida', False)
        self.proxy_setup = self.params.get('proxy', False)
        self.proxy_host = self.params.get('proxy_host', '')
        self.proxy_port = self.params.get('proxy_port', 8080)
        self.ssl_pinning_bypass = self.params.get('bypass_ssl', False)
        self.screen_mirror = self.params.get('mirror', False)
        self.auto_backup = self.params.get('backup', False)
        self.search_secrets = self.params.get('search_secrets', True)
        self.interactive_shell = self.params.get('shell', False)
        
        # Tools
        self.adb = self._find_tool('adb')
        self.aapt = self._find_tool('aapt')
        self.apktool = self._find_tool('apktool')
        self.jadx = self._find_tool('jadx')
        self.frida = self._find_tool('frida')
        self.objection = self._find_tool('objection')
        
        # Results
        self.device_info = None
        self.app_profiles = []
        self.vulnerabilities = []
        self.findings = []
        self.errors = []
        self.secret_findings = []
        
        # Working directory
        self.work_dir = Path(tempfile.mkdtemp(prefix='secv_android_'))
        self.backup_dir = self.work_dir / 'backups'
        self.backup_dir.mkdir(exist_ok=True)
    
    def _find_tool(self, tool_name: str) -> Optional[str]:
        """Find Android tool in PATH"""
        return shutil.which(tool_name)
    
    def _run_adb(self, command: List[str], timeout: int = 30) -> Tuple[int, str, str]:
        """Execute ADB command"""
        cmd = [self.adb] + command
        if self.serial:
            cmd.insert(1, '-s')
            cmd.insert(2, self.serial)
        
        try:
            proc = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout
            )
            return proc.returncode, proc.stdout, proc.stderr
        except subprocess.TimeoutExpired:
            return 1, "", "Command timed out"
        except Exception as e:
            return 1, "", str(e)
    
    def execute(self) -> Dict:
        """Execute penetration test"""
        if not self.adb:
            return {
                "success": False,
                "errors": ["ADB not found. Install: apt install android-tools-adb"]
            }
        
        # Start ADB server
        subprocess.run([self.adb, 'start-server'], capture_output=True)
        
        # Select device
        if not self.serial:
            self.serial = self._select_device()
            if not self.serial:
                return {
                    "success": False,
                    "errors": ["No Android devices found"]
                }
        
        # Execute operation
        operations = {
            'recon': self._recon_operation,
            'app_scan': self._app_scan_operation,
            'vuln_scan': self._vuln_scan_operation,
            'exploit': self._exploit_operation,
            'network': self._network_operation,
            'forensics': self._forensics_operation,
            'full': self._full_operation,
        }
        
        operation_func = operations.get(self.operation, self._recon_operation)
        
        try:
            operation_func()
            
            return {
                "success": True,
                "data": {
                    "operation": self.operation,
                    "device": asdict(self.device_info) if self.device_info else None,
                    "applications": [asdict(app) for app in self.app_profiles],
                    "vulnerabilities": self.vulnerabilities,
                    "findings": self.findings,
                    "summary": self._generate_summary(),
                },
                "errors": self.errors
            }
            
        except Exception as e:
            return {
                "success": False,
                "errors": [str(e)]
            }
        finally:
            # Cleanup
            if self.work_dir.exists():
                shutil.rmtree(self.work_dir, ignore_errors=True)
    
    # ========================================================================
    # DEVICE OPERATIONS
    # ========================================================================
    
    def _select_device(self) -> Optional[str]:
        """Select Android device"""
        rc, out, _ = self._run_adb(['devices'])
        if rc != 0:
            return None
        
        devices = []
        for line in out.strip().split('\n')[1:]:
            if '\t' in line:
                serial, state = line.split('\t')
                if state == 'device':
                    devices.append(serial)
        
        return devices[0] if devices else None
    
    def _get_device_info(self) -> AndroidDevice:
        """Gather comprehensive device information"""
        info = AndroidDevice(serial=self.serial)
        
        # Basic info
        props = {
            'model': 'ro.product.model',
            'manufacturer': 'ro.product.manufacturer',
            'android_version': 'ro.build.version.release',
            'sdk_version': 'ro.build.version.sdk',
            'architecture': 'ro.product.cpu.abi',
            'build_id': 'ro.build.id',
            'security_patch': 'ro.build.version.security_patch',
            'kernel_version': 'ro.boot.version',
        }
        
        for attr, prop in props.items():
            rc, out, _ = self._run_adb(['shell', 'getprop', prop])
            if rc == 0:
                setattr(info, attr, out.strip())
        
        # Device state
        rc, out, _ = self._run_adb(['get-state'])
        if rc == 0:
            info.state = out.strip()
        
        # Root check
        info.rooted = self._check_root()
        
        # SELinux status
        rc, out, _ = self._run_adb(['shell', 'getenforce'])
        if rc == 0:
            info.selinux_status = out.strip()
        
        # Encryption status
        rc, out, _ = self._run_adb(['shell', 'getprop', 'ro.crypto.state'])
        if rc == 0:
            info.encryption_status = out.strip()
        
        # Developer options
        rc, out, _ = self._run_adb(['shell', 'settings', 'get', 'global', 'development_settings_enabled'])
        if rc == 0 and out.strip() == '1':
            info.developer_mode = True
        
        # USB debugging
        rc, out, _ = self._run_adb(['shell', 'settings', 'get', 'global', 'adb_enabled'])
        if rc == 0 and out.strip() == '1':
            info.usb_debugging = True
        
        # Battery
        rc, out, _ = self._run_adb(['shell', 'dumpsys', 'battery'])
        if rc == 0:
            match = re.search(r'level:\s*(\d+)', out)
            if match:
                info.battery_level = int(match.group(1))
        
        # Bootloader status
        rc, out, _ = self._run_adb(['shell', 'getprop', 'ro.boot.flash.locked'])
        if rc == 0 and out.strip() == '0':
            info.bootloader_unlocked = True
        
        return info
    
    def _check_root(self) -> bool:
        """Check if device is rooted"""
        # Method 1: su binary
        rc, _, _ = self._run_adb(['shell', 'which', 'su'])
        if rc == 0:
            return True
        
        # Method 2: Magisk
        rc, _, _ = self._run_adb(['shell', 'which', 'magisk'])
        if rc == 0:
            return True
        
        # Method 3: SuperSU
        rc, out, _ = self._run_adb(['shell', 'pm', 'list', 'packages'])
        if 'eu.chainfire.supersu' in out:
            return True
        
        return False
    
    # ========================================================================
    # APPLICATION ANALYSIS
    # ========================================================================
    
    def _get_installed_apps(self) -> List[str]:
        """Get list of installed packages"""
        rc, out, _ = self._run_adb(['shell', 'pm', 'list', 'packages'])
        if rc != 0:
            return []
        
        packages = []
        for line in out.strip().split('\n'):
            if line.startswith('package:'):
                packages.append(line.replace('package:', ''))
        
        return packages
    
    def _analyze_application(self, package: str) -> AppSecurityProfile:
        """Comprehensive application security analysis"""
        profile = AppSecurityProfile(package_name=package)
        
        print(f"[*] Analyzing {package}...", file=sys.stderr)
        
        # Get APK path
        rc, out, _ = self._run_adb(['shell', 'pm', 'path', package])
        if rc != 0 or not out.strip():
            return profile
        
        apk_path = out.strip().replace('package:', '')
        
        # Pull APK
        local_apk = self.work_dir / f"{package}.apk"
        rc, _, _ = self._run_adb(['pull', apk_path, str(local_apk)])
        if rc != 0:
            self.errors.append(f"Failed to pull APK: {package}")
            return profile
        
        # Analyze APK
        self._analyze_apk_static(profile, local_apk)
        self._analyze_apk_manifest(profile, local_apk)
        self._analyze_apk_permissions(profile)
        self._analyze_apk_components(profile)
        self._analyze_apk_code(profile, local_apk)
        self._analyze_apk_certificate(profile, local_apk)
        
        # Runtime analysis
        self._analyze_app_runtime(profile)
        
        # Calculate security score
        self._calculate_security_score(profile)
        
        # Clean up
        if local_apk.exists():
            local_apk.unlink()
        
        return profile
    
    def _analyze_apk_static(self, profile: AppSecurityProfile, apk_path: Path):
        """Static APK analysis with AAPT"""
        if not self.aapt:
            return
        
        try:
            proc = subprocess.run(
                [self.aapt, 'dump', 'badging', str(apk_path)],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if proc.returncode == 0:
                out = proc.stdout
                
                # App name
                match = re.search(r"application-label:'([^']+)'", out)
                if match:
                    profile.app_name = match.group(1)
                
                # Version
                match = re.search(r"versionName='([^']+)'", out)
                if match:
                    profile.version_name = match.group(1)
                
                match = re.search(r"versionCode='([^']+)'", out)
                if match:
                    profile.version_code = match.group(1)
                
                # SDK versions
                match = re.search(r"sdkVersion:'(\d+)'", out)
                if match:
                    profile.min_sdk = match.group(1)
                
                match = re.search(r"targetSdkVersion:'(\d+)'", out)
                if match:
                    profile.target_sdk = match.group(1)
                
                # Native libraries
                for match in re.finditer(r"native-code:\s*'([^']+)'", out):
                    profile.native_libraries.extend(match.group(1).split())
        
        except Exception as e:
            self.errors.append(f"AAPT analysis failed: {e}")
    
    def _analyze_apk_manifest(self, profile: AppSecurityProfile, apk_path: Path):
        """Analyze AndroidManifest.xml"""
        if not self.aapt:
            return
        
        try:
            proc = subprocess.run(
                [self.aapt, 'dump', 'xmltree', str(apk_path), 'AndroidManifest.xml'],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if proc.returncode == 0:
                manifest = proc.stdout
                
                # Security flags
                profile.debuggable = 'android:debuggable(0x0101000f)=(type 0x12)0xffffffff' in manifest
                profile.allow_backup = 'android:allowBackup(0x01010280)=(type 0x12)0xffffffff' in manifest
                profile.cleartext_traffic = 'android:usesCleartextTraffic' in manifest
                profile.has_network_security_config = 'android:networkSecurityConfig' in manifest
                
                # Count components
                profile.activities = manifest.count('E: activity')
                profile.services = manifest.count('E: service')
                profile.receivers = manifest.count('E: receiver')
                profile.providers = manifest.count('E: provider')
                
                # Exported components
                exported_pattern = r'android:exported\(0x01010010\)=\(type 0x12\)0xffffffff'
                
                # This is simplified - real analysis would parse XML properly
                profile.exported_activities = len(re.findall(exported_pattern, manifest))
        
        except Exception as e:
            self.errors.append(f"Manifest analysis failed: {e}")
    
    def _analyze_apk_permissions(self, profile: AppSecurityProfile):
        """Analyze application permissions"""
        rc, out, _ = self._run_adb(['shell', 'dumpsys', 'package', profile.package_name])
        if rc != 0:
            return
        
        # Extract permissions
        in_permissions = False
        for line in out.split('\n'):
            line = line.strip()
            
            if 'declared permissions:' in line.lower():
                in_permissions = True
                continue
            
            if in_permissions:
                if line.startswith('permission:'):
                    perm = line.replace('permission:', '').strip()
                    profile.permissions.append(perm)
                    
                    if perm in DANGEROUS_PERMISSIONS:
                        profile.dangerous_permissions.append(perm)
                
                elif not line or line.startswith('User '):
                    break
        
        # Get granted permissions
        rc, out, _ = self._run_adb(['shell', 'dumpsys', 'package', profile.package_name])
        if rc == 0:
            if 'granted=true' in out:
                profile.permissions.extend(re.findall(r'(android\.permission\.\w+):\s+granted=true', out))
    
    def _analyze_apk_components(self, profile: AppSecurityProfile):
        """Analyze exposed components"""
        rc, out, _ = self._run_adb(['shell', 'dumpsys', 'package', profile.package_name])
        if rc != 0:
            return
        
        # Count exported components
        profile.exported_activities = out.count('Activity') if 'exported=true' in out else 0
        profile.exported_services = out.count('Service') if 'exported=true' in out else 0
        profile.exported_receivers = out.count('Receiver') if 'exported=true' in out else 0
        profile.exported_providers = out.count('Provider') if 'exported=true' in out else 0
    
    def _analyze_apk_code(self, profile: AppSecurityProfile, apk_path: Path):
        """Static code analysis for vulnerabilities"""
        if not CAPABILITIES.get('zipfile'):
            return
        
        try:
            with zipfile.ZipFile(apk_path, 'r') as zf:
                # Check for obfuscation
                if 'classes.dex' in zf.namelist():
                    # Simple heuristic - real analysis would decompile
                    dex_size = zf.getinfo('classes.dex').file_size
                    if dex_size > 1000000:  # Large DEX might indicate obfuscation
                        profile.has_obfuscation = True
                
                # Extract and analyze DEX files (simplified)
                for name in zf.namelist():
                    if name.endswith('.dex'):
                        # In real implementation, decompile and scan
                        pass
        
        except Exception as e:
            self.errors.append(f"Code analysis failed: {e}")
    
    def _analyze_apk_certificate(self, profile: AppSecurityProfile, apk_path: Path):
        """Analyze APK signing certificate"""
        try:
            proc = subprocess.run(
                ['keytool', '-printcert', '-jarfile', str(apk_path)],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if proc.returncode == 0:
                cert_info = proc.stdout
                
                profile.certificate_info = {
                    'issuer': self._extract_cert_field(cert_info, 'Owner'),
                    'valid_from': self._extract_cert_field(cert_info, 'Valid from'),
                    'valid_until': self._extract_cert_field(cert_info, 'until'),
                    'serial': self._extract_cert_field(cert_info, 'Serial number'),
                    'signature_algorithm': self._extract_cert_field(cert_info, 'Signature algorithm'),
                }
                
                # Check for debug certificate
                if 'CN=Android Debug' in cert_info:
                    profile.vulnerabilities.append({
                        'type': 'DEBUG_CERTIFICATE',
                        'severity': 'HIGH',
                        'description': 'Application signed with debug certificate',
                        'recommendation': 'Release apps should use production certificates'
                    })
        
        except Exception as e:
            pass  # keytool might not be available
    
    def _extract_cert_field(self, cert_text: str, field: str) -> str:
        """Extract field from certificate text"""
        match = re.search(f'{field}:?\\s*(.+?)\\n', cert_text)
        return match.group(1).strip() if match else ""
    
    def _analyze_app_runtime(self, profile: AppSecurityProfile):
        """Runtime application analysis"""
        # Get app info
        rc, out, _ = self._run_adb(['shell', 'dumpsys', 'package', profile.package_name])
        if rc == 0:
            # Data directory
            match = re.search(r'dataDir=(/[^\s]+)', out)
            if match:
                profile.data_directory = match.group(1)
            
            # UID
            match = re.search(r'userId=(\d+)', out)
            if match:
                profile.uid = match.group(1)
            
            # Install location
            match = re.search(r'codePath=(/[^\s]+)', out)
            if match:
                profile.install_location = match.group(1)
    
    def _calculate_security_score(self, profile: AppSecurityProfile):
        """Calculate application security score"""
        score = 100
        
        # Deductions
        if profile.debuggable:
            score -= 20
            profile.vulnerabilities.append({
                'type': 'DEBUGGABLE',
                'severity': 'HIGH',
                'description': 'Application is debuggable',
                'recommendation': 'Disable debugging in production builds'
            })
        
        if profile.allow_backup:
            score -= 10
            profile.vulnerabilities.append({
                'type': 'BACKUP_ENABLED',
                'severity': 'MEDIUM',
                'description': 'Backup is allowed (data can be extracted)',
                'recommendation': 'Set android:allowBackup="false" for sensitive apps'
            })
        
        if profile.cleartext_traffic:
            score -= 15
            profile.vulnerabilities.append({
                'type': 'CLEARTEXT_TRAFFIC',
                'severity': 'HIGH',
                'description': 'Cleartext network traffic is allowed',
                'recommendation': 'Enforce HTTPS-only communication'
            })
        
        if len(profile.dangerous_permissions) > 5:
            score -= 10
            profile.vulnerabilities.append({
                'type': 'EXCESSIVE_PERMISSIONS',
                'severity': 'MEDIUM',
                'description': f'{len(profile.dangerous_permissions)} dangerous permissions requested',
                'recommendation': 'Request only necessary permissions'
            })
        
        if profile.exported_activities > 0 or profile.exported_services > 0:
            score -= 10
            profile.vulnerabilities.append({
                'type': 'EXPORTED_COMPONENTS',
                'severity': 'MEDIUM',
                'description': 'Application has exported components',
                'recommendation': 'Review exported components and add permission protection'
            })
        
        if int(profile.target_sdk or '0') < 28:
            score -= 10
            profile.vulnerabilities.append({
                'type': 'OUTDATED_TARGET_SDK',
                'severity': 'MEDIUM',
                'description': f'Target SDK {profile.target_sdk} is outdated',
                'recommendation': 'Update to latest Android API level'
            })
        
        profile.security_score = max(0, score)
        
        # Risk level
        if score >= 80:
            profile.risk_level = "LOW"
        elif score >= 60:
            profile.risk_level = "MEDIUM"
        elif score >= 40:
            profile.risk_level = "HIGH"
        else:
            profile.risk_level = "CRITICAL"
    
    # ========================================================================
    # OPERATIONS
    # ========================================================================
    
    def _recon_operation(self):
        """Device reconnaissance"""
        print("[*] Starting reconnaissance...", file=sys.stderr)
        
        self.device_info = self._get_device_info()
        
        self.findings.append({
            'category': 'device_info',
            'data': asdict(self.device_info)
        })
        
        # Check for security issues
        if self.device_info.rooted:
            self.findings.append({
                'category': 'security',
                'severity': 'CRITICAL',
                'finding': 'Device is rooted - all security controls can be bypassed'
            })
        
        if self.device_info.bootloader_unlocked:
            self.findings.append({
                'category': 'security',
                'severity': 'HIGH',
                'finding': 'Bootloader is unlocked - firmware can be modified'
            })
        
        if self.device_info.selinux_status != 'Enforcing':
            self.findings.append({
                'category': 'security',
                'severity': 'HIGH',
                'finding': f'SELinux is {self.device_info.selinux_status} - kernel exploits easier'
            })
        
        if self.device_info.developer_mode:
            self.findings.append({
                'category': 'security',
                'severity': 'MEDIUM',
                'finding': 'Developer mode is enabled - attack surface increased'
            })
    
    def _app_scan_operation(self):
        """Scan applications for vulnerabilities"""
        print("[*] Scanning applications...", file=sys.stderr)
        
        packages = [self.package] if self.package else self._get_installed_apps()
        
        # Limit scan if no specific package
        if not self.package:
            packages = packages[:10]  # Sample first 10 apps
        
        for pkg in packages:
            profile = self._analyze_application(pkg)
            self.app_profiles.append(profile)
            
            # Add vulnerabilities to findings
            for vuln in profile.vulnerabilities:
                self.vulnerabilities.append({
                    'package': pkg,
                    **vuln
                })
    
    def _vuln_scan_operation(self):
        """Deep vulnerability scanning"""
        print("[*] Starting vulnerability scan...", file=sys.stderr)
        
        # Device recon first
        self._recon_operation()
        
        # App scanning
        self._app_scan_operation()
        
        # Additional vulnerability checks
        self._check_common_vulns()
        self._check_known_vulnerable_apps()
        self._check_exposed_services()
    
    def _check_common_vulns(self):
        """Check for common Android vulnerabilities"""
        print("[*] Checking common vulnerabilities...", file=sys.stderr)
        
        # Check for ADB over network
        rc, out, _ = self._run_adb(['shell', 'getprop', 'service.adb.tcp.port'])
        if rc == 0 and out.strip() and out.strip() != '-1':
            self.vulnerabilities.append({
                'type': 'ADB_NETWORK',
                'severity': 'CRITICAL',
                'description': f'ADB over network enabled on port {out.strip()}',
                'recommendation': 'Disable ADB over network: setprop service.adb.tcp.port -1'
            })
        
        # Check for world-readable files
        rc, out, _ = self._run_adb(['shell', 'find', '/sdcard', '-type', 'f', '-perm', '0666'])
        if rc == 0:
            readable_files = [f for f in out.strip().split('\n') if f]
            if readable_files:
                self.vulnerabilities.append({
                    'type': 'WORLD_READABLE_FILES',
                    'severity': 'MEDIUM',
                    'description': f'Found {len(readable_files)} world-readable files',
                    'files': readable_files[:10]  # Sample
                })
        
        # Check for insecure settings
        settings_to_check = [
            ('global', 'adb_enabled', 'ADB enabled'),
            ('global', 'install_non_market_apps', 'Unknown sources enabled'),
            ('secure', 'mock_location', 'Mock location enabled'),
        ]
        
        for namespace, key, desc in settings_to_check:
            rc, out, _ = self._run_adb(['shell', 'settings', 'get', namespace, key])
            if rc == 0 and out.strip() == '1':
                self.findings.append({
                    'category': 'configuration',
                    'severity': 'LOW',
                    'finding': desc
                })
    
    def _check_known_vulnerable_apps(self):
        """Check for known vulnerable applications"""
        rc, out, _ = self._run_adb(['shell', 'pm', 'list', 'packages'])
        if rc != 0:
            return
        
        installed = [line.replace('package:', '') for line in out.strip().split('\n')]
        
        for pkg, info in KNOWN_VULNS.items():
            if pkg in installed:
                self.vulnerabilities.append({
                    'package': pkg,
                    'type': 'KNOWN_VULNERABLE_APP',
                    'severity': info['severity'],
                    'description': f'{info["name"]} is installed',
                    'vulnerabilities': info['vulns'],
                    'recommendation': 'This is a deliberately vulnerable app for training'
                })
    
    def _check_exposed_services(self):
        """Check for exposed network services"""
        rc, out, _ = self._run_adb(['shell', 'netstat', '-tuln'])
        if rc == 0:
            listening_ports = []
            for line in out.split('\n'):
                if 'LISTEN' in line:
                    match = re.search(r':(\d+)\s', line)
                    if match:
                        listening_ports.append(int(match.group(1)))
            
            if listening_ports:
                self.findings.append({
                    'category': 'network',
                    'severity': 'INFO',
                    'finding': f'Listening ports: {listening_ports}'
                })
    
    def _exploit_operation(self):
        """Exploitation attempts (ethical)"""
        print("[*] Testing exploitation vectors...", file=sys.stderr)
        
        if not self.package:
            self.errors.append("Package name required for exploitation testing")
            return
        
        # Test intent injection
        self._test_intent_injection()
        
        # Test SQL injection
        self._test_sql_injection()
        
        # Test path traversal
        self._test_path_traversal()
        
        # Test exported components
        self._test_exported_components()
    
    def _test_intent_injection(self):
        """Test for intent injection vulnerabilities"""
        print("[*] Testing intent injection...", file=sys.stderr)
        
        # Get exported activities
        rc, out, _ = self._run_adb(['shell', 'dumpsys', 'package', self.package])
        if rc != 0:
            return
        
        # Extract exported activities (simplified)
        activities = re.findall(r'Activity.*?name=([^\s]+)', out)
        
        for activity in activities[:3]:  # Test first 3
            # Try launching with intent
            rc, _, _ = self._run_adb([
                'shell', 'am', 'start', '-n',
                f'{self.package}/{activity}'
            ])
            
            if rc == 0:
                self.findings.append({
                    'category': 'exploitation',
                    'type': 'INTENT_INJECTION',
                    'severity': 'MEDIUM',
                    'finding': f'Activity {activity} can be launched externally'
                })
    
    def _test_sql_injection(self):
        """Test for SQL injection in content providers"""
        print("[*] Testing SQL injection...", file=sys.stderr)
        
        # Get content providers
        rc, out, _ = self._run_adb(['shell', 'dumpsys', 'package', self.package])
        if rc != 0:
            return
        
        # Extract providers
        providers = re.findall(r'Provider.*?authority=([^\s]+)', out)
        
        for provider in providers[:3]:
            # Test with SQL injection payload
            test_queries = [
                f"content://{provider}/table' OR '1'='1",
                f"content://{provider}/table/1'; DROP TABLE users--",
            ]
            
            for query in test_queries:
                rc, out, err = self._run_adb(['shell', 'content', 'query', '--uri', query])
                
                # Check for SQL error indicators
                if 'sqlite' in err.lower() or 'syntax error' in err.lower():
                    self.vulnerabilities.append({
                        'package': self.package,
                        'type': 'SQL_INJECTION',
                        'severity': 'CRITICAL',
                        'description': f'Potential SQL injection in provider {provider}',
                        'recommendation': 'Use parameterized queries',
                        'payload': query
                    })
                    break
    
    def _test_path_traversal(self):
        """Test for path traversal vulnerabilities"""
        print("[*] Testing path traversal...", file=sys.stderr)
        
        # Try accessing sensitive files through content providers
        sensitive_paths = [
            '../../../etc/passwd',
            '../../../data/data/com.android.providers.settings/databases/settings.db',
            '../../../../system/build.prop',
        ]
        
        for path in sensitive_paths:
            rc, out, _ = self._run_adb([
                'shell', 'content', 'query', '--uri',
                f'content://{self.package}.provider/{path}'
            ])
            
            if rc == 0 and len(out) > 50:
                self.vulnerabilities.append({
                    'package': self.package,
                    'type': 'PATH_TRAVERSAL',
                    'severity': 'HIGH',
                    'description': 'Path traversal vulnerability detected',
                    'path': path
                })
    
    def _test_exported_components(self):
        """Test exported components for vulnerabilities"""
        print("[*] Testing exported components...", file=sys.stderr)
        
        # Test exported services
        rc, out, _ = self._run_adb(['shell', 'dumpsys', 'package', self.package])
        if rc != 0:
            return
        
        services = re.findall(r'Service.*?name=([^\s]+).*?exported=true', out)
        
        for service in services[:3]:
            # Try starting the service
            rc, _, _ = self._run_adb([
                'shell', 'am', 'startservice',
                f'{self.package}/{service}'
            ])
            
            if rc == 0:
                self.findings.append({
                    'category': 'exploitation',
                    'type': 'EXPORTED_SERVICE',
                    'severity': 'MEDIUM',
                    'finding': f'Service {service} can be started externally'
                })
    
    def _network_operation(self):
        """Network traffic analysis"""
        print("[*] Starting network analysis...", file=sys.stderr)
        
        if not self.package:
            self.errors.append("Package name required for network analysis")
            return
        
        # Start tcpdump if available
        capture_file = f'/sdcard/capture_{int(time.time())}.pcap'
        
        print(f"[*] Starting packet capture to {capture_file}...", file=sys.stderr)
        
        # Start capture in background
        self._run_adb(['shell', 'su', '-c', f'tcpdump -i any -w {capture_file} &'])
        
        # Launch app
        rc, out, _ = self._run_adb(['shell', 'monkey', '-p', self.package, '-c', 'android.intent.category.LAUNCHER', '1'])
        
        # Wait for activity
        time.sleep(10)
        
        # Stop capture
        self._run_adb(['shell', 'su', '-c', 'killall tcpdump'])
        
        # Pull capture
        local_capture = self.work_dir / 'capture.pcap'
        rc, _, _ = self._run_adb(['pull', capture_file, str(local_capture)])
        
        if rc == 0:
            self.findings.append({
                'category': 'network',
                'finding': f'Packet capture saved to {local_capture}'
            })
            
            # Analyze capture (simplified)
            self._analyze_pcap(local_capture)
        
        # Cleanup
        self._run_adb(['shell', 'rm', capture_file])
    
    def _analyze_pcap(self, pcap_file: Path):
        """Analyze PCAP file for security issues"""
        # This would require pyshark or scapy
        # Simplified version
        self.findings.append({
            'category': 'network',
            'finding': 'Use Wireshark to analyze: ' + str(pcap_file)
        })
    
    def _forensics_operation(self):
        """Forensics and data extraction"""
        print("[*] Starting forensics analysis...", file=sys.stderr)
        
        # Device info
        self._recon_operation()
        
        # Extract system info
        self._extract_system_info()
        
        # Extract app data
        if self.package:
            self._extract_app_data()
        
        # Extract logs
        self._extract_logs()
        
        # Extract SMS/Contacts (requires root)
        if self.device_info.rooted:
            self._extract_sensitive_data()
    
    def _extract_system_info(self):
        """Extract system information"""
        print("[*] Extracting system information...", file=sys.stderr)
        
        system_files = [
            '/system/build.prop',
            '/proc/version',
            '/proc/cpuinfo',
            '/proc/meminfo',
        ]
        
        for file_path in system_files:
            rc, out, _ = self._run_adb(['shell', 'cat', file_path])
            if rc == 0:
                local_file = self.work_dir / file_path.replace('/', '_')
                local_file.write_text(out)
                
                self.findings.append({
                    'category': 'forensics',
                    'type': 'system_file',
                    'file': file_path,
                    'extracted_to': str(local_file)
                })
    
    def _extract_app_data(self):
        """Extract application data"""
        print(f"[*] Extracting data for {self.package}...", file=sys.stderr)
        
        # Get app data directory
        rc, out, _ = self._run_adb(['shell', 'dumpsys', 'package', self.package])
        if rc != 0:
            return
        
        match = re.search(r'dataDir=(/[^\s]+)', out)
        if not match:
            return
        
        data_dir = match.group(1)
        
        # Pull databases
        db_dir = f'{data_dir}/databases'
        rc, out, _ = self._run_adb(['shell', 'ls', db_dir])
        
        if rc == 0:
            for db_file in out.strip().split('\n'):
                if db_file and db_file.endswith('.db'):
                    local_db = self.work_dir / db_file
                    self._run_adb(['pull', f'{db_dir}/{db_file}', str(local_db)])
                    
                    self.findings.append({
                        'category': 'forensics',
                        'type': 'database',
                        'package': self.package,
                        'database': db_file,
                        'location': str(local_db)
                    })
        
        # Pull shared preferences
        prefs_dir = f'{data_dir}/shared_prefs'
        rc, out, _ = self._run_adb(['shell', 'ls', prefs_dir])
        
        if rc == 0:
            for pref_file in out.strip().split('\n'):
                if pref_file and pref_file.endswith('.xml'):
                    local_pref = self.work_dir / pref_file
                    self._run_adb(['pull', f'{prefs_dir}/{pref_file}', str(local_pref)])
                    
                    # Check for sensitive data
                    if local_pref.exists():
                        content = local_pref.read_text()
                        
                        # Look for credentials
                        sensitive_patterns = [
                            r'password["\']?\s*[:=]\s*["\']([^"\']+)',
                            r'token["\']?\s*[:=]\s*["\']([^"\']+)',
                            r'api[_-]?key["\']?\s*[:=]\s*["\']([^"\']+)',
                        ]
                        
                        for pattern in sensitive_patterns:
                            matches = re.findall(pattern, content, re.IGNORECASE)
                            if matches:
                                self.vulnerabilities.append({
                                    'package': self.package,
                                    'type': 'SENSITIVE_DATA_STORAGE',
                                    'severity': 'HIGH',
                                    'description': 'Sensitive data found in SharedPreferences',
                                    'file': pref_file,
                                    'data_samples': matches[:3]
                                })
    
    def _extract_logs(self):
        """Extract system logs"""
        print("[*] Extracting logs...", file=sys.stderr)
        
        log_types = ['main', 'system', 'crash']
        
        for log_type in log_types:
            rc, out, _ = self._run_adb(['logcat', '-d', '-b', log_type])
            if rc == 0:
                log_file = self.work_dir / f'logcat_{log_type}.txt'
                log_file.write_text(out)
                
                # Check for sensitive info in logs
                sensitive_patterns = [
                    (r'password', 'PASSWORD_IN_LOGS'),
                    (r'api[_-]?key', 'API_KEY_IN_LOGS'),
                    (r'\b\d{16}\b', 'CREDIT_CARD_IN_LOGS'),
                ]
                
                for pattern, vuln_type in sensitive_patterns:
                    if re.search(pattern, out, re.IGNORECASE):
                        self.vulnerabilities.append({
                            'type': vuln_type,
                            'severity': 'HIGH',
                            'description': f'Sensitive data found in {log_type} logs',
                            'log_file': str(log_file)
                        })
    
    def _extract_sensitive_data(self):
        """Extract sensitive data (requires root)"""
        print("[*] Extracting sensitive data (requires root)...", file=sys.stderr)
        
        # SMS database
        sms_db = '/data/data/com.android.providers.telephony/databases/mmssms.db'
        local_sms = self.work_dir / 'sms.db'
        rc, _, _ = self._run_adb(['shell', 'su', '-c', f'cat {sms_db}'], timeout=60)
        
        if rc == 0:
            self._run_adb(['pull', sms_db, str(local_sms)])
            self.findings.append({
                'category': 'forensics',
                'type': 'sensitive_data',
                'data': 'SMS database',
                'location': str(local_sms)
            })
        
        # Contacts database
        contacts_db = '/data/data/com.android.providers.contacts/databases/contacts2.db'
        local_contacts = self.work_dir / 'contacts.db'
        rc, _, _ = self._run_adb(['shell', 'su', '-c', f'cat {contacts_db}'], timeout=60)
        
        if rc == 0:
            self._run_adb(['pull', contacts_db, str(local_contacts)])
            self.findings.append({
                'category': 'forensics',
                'type': 'sensitive_data',
                'data': 'Contacts database',
                'location': str(local_contacts)
            })
    
    def _full_operation(self):
        """Full penetration test"""
        print("[*] Starting full penetration test...", file=sys.stderr)
        
        self._recon_operation()
        self._app_scan_operation()
        self._vuln_scan_operation()
        
        if self.package:
            self._exploit_operation()
            self._network_operation()
            self._forensics_operation()
            
            # HacknDroid advanced features
            if self.search_secrets:
                self._advanced_secret_search()
            
            if self.enable_frida:
                self._frida_operations()
            
            if self.proxy_setup:
                self._setup_proxy()
            
            if self.ssl_pinning_bypass:
                self._bypass_ssl_pinning()
            
            if self.auto_backup:
                self._create_full_backup()
    
    # ========================================================================
    # HACKNDROID ADVANCED FEATURES
    # ========================================================================
    
    def _advanced_secret_search(self):
        """Advanced secret and pattern search in APK"""
        print("[*] Starting advanced secret search...", file=sys.stderr)
        
        if not self.package:
            return
        
        # Get APK
        rc, out, _ = self._run_adb(['shell', 'pm', 'path', self.package])
        if rc != 0:
            return
        
        apk_path = out.strip().replace('package:', '')
        local_apk = self.work_dir / f"{self.package}.apk"
        self._run_adb(['pull', apk_path, str(local_apk)])
        
        if not local_apk.exists():
            return
        
        # Decompile with apktool
        if self.apktool:
            decompiled_dir = self.work_dir / 'decompiled'
            try:
                subprocess.run(
                    [self.apktool, 'd', str(local_apk), '-o', str(decompiled_dir), '-f'],
                    capture_output=True,
                    timeout=120
                )
                
                if decompiled_dir.exists():
                    self._search_secrets_recursive(decompiled_dir)
            except Exception as e:
                self.errors.append(f"Decompilation failed: {e}")
    
    def _search_secrets_recursive(self, directory: Path):
        """Recursively search for secrets in decompiled code"""
        secret_patterns = {
            'AWS_KEY': r'AKIA[0-9A-Z]{16}',
            'API_KEY': r'[aA][pP][iI][_-]?[kK][eE][yY]["\']?\s*[:=]\s*["\']([^"\']{16,})["\']',
            'PASSWORD': r'[pP][aA][sS][sS][wW][oO][rR][dD]["\']?\s*[:=]\s*["\']([^"\']+)["\']',
            'SECRET': r'[sS][eE][cC][rR][eE][tT]["\']?\s*[:=]\s*["\']([^"\']{16,})["\']',
            'TOKEN': r'[tT][oO][kK][eE][nN]["\']?\s*[:=]\s*["\']([^"\']{16,})["\']',
            'PRIVATE_KEY': r'-----BEGIN (?:RSA |EC )?PRIVATE KEY-----',
            'JWT': r'eyJ[A-Za-z0-9_-]+\.eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+',
            'CREDIT_CARD': r'\b\d{4}[- ]?\d{4}[- ]?\d{4}[- ]?\d{4}\b',
            'PHONE': r'\+?1?\d{9,15}',
            'EMAIL': r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',
            'IP_ADDRESS': r'\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b',
            'URL': r'https?://[^\s<>"{}|\\^`\[\]]+',
            'BASE64_LONG': r'[A-Za-z0-9+/]{40,}={0,2}',
            'HEX_KEY': r'[0-9a-fA-F]{32,}',
        }
        
        for file_path in directory.rglob('*'):
            if file_path.is_file() and file_path.suffix in ['.smali', '.xml', '.java', '.txt', '.json', '.properties']:
                try:
                    content = file_path.read_text(errors='ignore')
                    
                    for secret_type, pattern in secret_patterns.items():
                        matches = re.findall(pattern, content)
                        if matches:
                            for match in matches[:5]:  # Limit to 5 per file
                                match_str = match if isinstance(match, str) else match[0] if match else ""
                                
                                self.secret_findings.append({
                                    'type': secret_type,
                                    'file': str(file_path.relative_to(directory)),
                                    'value': match_str[:50] + '...' if len(match_str) > 50 else match_str,
                                    'line': self._get_line_number(content, match_str)
                                })
                                
                                self.vulnerabilities.append({
                                    'package': self.package,
                                    'type': f'HARDCODED_{secret_type}',
                                    'severity': 'CRITICAL' if secret_type in ['AWS_KEY', 'PRIVATE_KEY', 'PASSWORD'] else 'HIGH',
                                    'description': f'{secret_type} found in {file_path.name}',
                                    'file': str(file_path.relative_to(directory)),
                                    'recommendation': 'Remove hardcoded secrets, use secure storage'
                                })
                
                except Exception as e:
                    continue
    
    def _get_line_number(self, content: str, search_str: str) -> int:
        """Get line number of match"""
        lines = content.split('\n')
        for i, line in enumerate(lines, 1):
            if search_str in line:
                return i
        return 0
    
    def _frida_operations(self):
        """Frida instrumentation and SSL pinning bypass"""
        print("[*] Starting Frida operations...", file=sys.stderr)
        
        if not self.frida:
            self.errors.append("Frida not installed")
            return
        
        # Check if frida-server is running
        rc, out, _ = self._run_adb(['shell', 'ps', '-A'])
        if 'frida-server' not in out:
            print("[!] Frida server not running on device", file=sys.stderr)
            self.findings.append({
                'category': 'frida',
                'finding': 'Frida server not running - start with: adb shell /data/local/tmp/frida-server &'
            })
            return
        
        # List applications
        try:
            proc = subprocess.run(
                [self.frida, '-U', '-f', self.package, '--no-pause', '-l', self._get_frida_script()],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            self.findings.append({
                'category': 'frida',
                'output': proc.stdout
            })
        
        except Exception as e:
            self.errors.append(f"Frida execution failed: {e}")
    
    def _get_frida_script(self) -> str:
        """Generate Frida script for common hooks"""
        script = self.work_dir / 'frida_script.js'
        
        frida_code = """
Java.perform(function() {
    console.log('[*] Frida attached to process');
    
    // SSL Pinning Bypass
    try {
        var SSLContext = Java.use('javax.net.ssl.SSLContext');
        SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;', '[Ljavax.net.ssl.TrustManager;', 'java.security.SecureRandom').implementation = function(a,b,c) {
            console.log('[+] SSL Pinning bypassed');
            this.init(a, null, c);
        }
    } catch(e) {
        console.log('[-] SSL bypass failed: ' + e);
    }
    
    // Root detection bypass
    try {
        var RootBeer = Java.use('com.scottyab.rootbeer.RootBeer');
        RootBeer.isRooted.implementation = function() {
            console.log('[+] Root detection bypassed');
            return false;
        }
    } catch(e) {}
    
    // Log all crypto operations
    try {
        var Cipher = Java.use('javax.crypto.Cipher');
        Cipher.getInstance.overload('java.lang.String').implementation = function(transformation) {
            console.log('[*] Cipher: ' + transformation);
            return this.getInstance(transformation);
        }
    } catch(e) {}
});
"""
        script.write_text(frida_code)
        return str(script)
    
    def _setup_proxy(self):
        """Setup HTTP proxy on device"""
        print(f"[*] Setting up proxy {self.proxy_host}:{self.proxy_port}...", file=sys.stderr)
        
        if not self.proxy_host:
            # Get local IP
            try:
                import socket
                s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                s.connect(("8.8.8.8", 80))
                self.proxy_host = s.getsockname()[0]
                s.close()
            except:
                self.proxy_host = "192.168.1.1"
        
        # Set global proxy
        self._run_adb(['shell', 'settings', 'put', 'global', 'http_proxy', f'{self.proxy_host}:{self.proxy_port}'])
        
        self.findings.append({
            'category': 'proxy',
            'finding': f'Proxy configured: {self.proxy_host}:{self.proxy_port}'
        })
    
    def _bypass_ssl_pinning(self):
        """Bypass SSL certificate pinning"""
        print("[*] Attempting SSL pinning bypass...", file=sys.stderr)
        
        if self.objection:
            try:
                # Use objection for SSL pinning bypass
                proc = subprocess.run(
                    [self.objection, '-g', self.package, 'explore', '-q', 
                     'android sslpinning disable'],
                    capture_output=True,
                    text=True,
                    timeout=30
                )
                
                if proc.returncode == 0:
                    self.findings.append({
                        'category': 'ssl_pinning',
                        'finding': 'SSL pinning bypass attempted via objection'
                    })
            except Exception as e:
                self.errors.append(f"Objection SSL bypass failed: {e}")
        elif self.frida:
            # Use Frida script
            self._frida_operations()
    
    def _create_full_backup(self):
        """Create full device/app backup"""
        print("[*] Creating backup...", file=sys.stderr)
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        if self.package:
            # App-specific backup
            backup_file = self.backup_dir / f'{self.package}_{timestamp}.ab'
            
            rc, _, _ = self._run_adb([
                'backup', '-f', str(backup_file), '-apk', self.package
            ], timeout=300)
            
            if rc == 0 and backup_file.exists():
                self.findings.append({
                    'category': 'backup',
                    'type': 'app_backup',
                    'package': self.package,
                    'file': str(backup_file),
                    'size': backup_file.stat().st_size
                })
                
                # Also backup APK
                rc, out, _ = self._run_adb(['shell', 'pm', 'path', self.package])
                if rc == 0:
                    apk_path = out.strip().replace('package:', '')
                    apk_backup = self.backup_dir / f'{self.package}_{timestamp}.apk'
                    self._run_adb(['pull', apk_path, str(apk_backup)])
                    
                    if apk_backup.exists():
                        self.findings.append({
                            'category': 'backup',
                            'type': 'apk_backup',
                            'file': str(apk_backup)
                        })
        else:
            # Full device backup
            backup_file = self.backup_dir / f'full_backup_{timestamp}.ab'
            
            rc, _, _ = self._run_adb([
                'backup', '-f', str(backup_file), '-all', '-apk', '-system'
            ], timeout=3600)
            
            if rc == 0 and backup_file.exists():
                self.findings.append({
                    'category': 'backup',
                    'type': 'full_backup',
                    'file': str(backup_file),
                    'size': backup_file.stat().st_size
                })
    
    def _screen_operations(self):
        """Screen recording and screenshot"""
        print("[*] Performing screen operations...", file=sys.stderr)
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        # Screenshot
        screenshot_device = f'/sdcard/screenshot_{timestamp}.png'
        screenshot_local = self.work_dir / f'screenshot_{timestamp}.png'
        
        self._run_adb(['shell', 'screencap', screenshot_device])
        self._run_adb(['pull', screenshot_device, str(screenshot_local)])
        self._run_adb(['shell', 'rm', screenshot_device])
        
        if screenshot_local.exists():
            self.findings.append({
                'category': 'screen',
                'type': 'screenshot',
                'file': str(screenshot_local)
            })
        
        # Screen recording (30 seconds)
        if self.params.get('record', False):
            video_device = f'/sdcard/recording_{timestamp}.mp4'
            video_local = self.work_dir / f'recording_{timestamp}.mp4'
            
            print("[*] Recording screen for 30 seconds...", file=sys.stderr)
            self._run_adb(['shell', 'screenrecord', '--time-limit', '30', video_device], timeout=35)
            self._run_adb(['pull', video_device, str(video_local)])
            self._run_adb(['shell', 'rm', video_device])
            
            if video_local.exists():
                self.findings.append({
                    'category': 'screen',
                    'type': 'recording',
                    'file': str(video_local)
                })
    
    def _process_management(self):
        """List and analyze running processes"""
        print("[*] Analyzing running processes...", file=sys.stderr)
        
        rc, out, _ = self._run_adb(['shell', 'ps', '-A'])
        if rc != 0:
            return
        
        processes = []
        suspicious_processes = []
        
        for line in out.strip().split('\n')[1:]:
            parts = line.split()
            if len(parts) >= 9:
                proc_info = {
                    'user': parts[0],
                    'pid': parts[1],
                    'ppid': parts[2],
                    'name': parts[-1]
                }
                processes.append(proc_info)
                
                # Check for suspicious processes
                suspicious_keywords = ['frida', 'xposed', 'magisk', 'supersu', 'root', 'hook']
                if any(keyword in proc_info['name'].lower() for keyword in suspicious_keywords):
                    suspicious_processes.append(proc_info)
        
        self.findings.append({
            'category': 'processes',
            'total': len(processes),
            'suspicious': suspicious_processes
        })
    
    def _network_analysis(self):
        """Advanced network analysis"""
        print("[*] Performing network analysis...", file=sys.stderr)
        
        # Get network connections
        rc, out, _ = self._run_adb(['shell', 'netstat', '-tuln'])
        if rc == 0:
            listening = []
            for line in out.split('\n'):
                if 'LISTEN' in line:
                    listening.append(line.strip())
            
            self.findings.append({
                'category': 'network',
                'listening_ports': listening
            })
        
        # Check WiFi info
        rc, out, _ = self._run_adb(['shell', 'dumpsys', 'wifi'])
        if rc == 0:
            wifi_info = {}
            
            # Extract SSID
            match = re.search(r'mWifiInfo.*?"([^"]+)"', out)
            if match:
                wifi_info['ssid'] = match.group(1)
            
            # Extract IP
            match = re.search(r'ip\s+(\d+\.\d+\.\d+\.\d+)', out)
            if match:
                wifi_info['ip'] = match.group(1)
            
            self.findings.append({
                'category': 'network',
                'wifi': wifi_info
            })
    
    def _certificate_management(self):
        """TLS certificate extraction and analysis"""
        print("[*] Analyzing certificates...", file=sys.stderr)
        
        if not self.package:
            return
        
        # Get APK
        rc, out, _ = self._run_adb(['shell', 'pm', 'path', self.package])
        if rc != 0:
            return
        
        apk_path = out.strip().replace('package:', '')
        local_apk = self.work_dir / f'{self.package}.apk'
        self._run_adb(['pull', apk_path, str(local_apk)])
        
        if local_apk.exists() and CAPABILITIES.get('zipfile'):
            try:
                import zipfile
                with zipfile.ZipFile(local_apk, 'r') as zf:
                    # Extract certificates
                    for name in zf.namelist():
                        if name.startswith('META-INF/') and name.endswith(('.RSA', '.DSA', '.EC')):
                            cert_data = zf.read(name)
                            cert_file = self.work_dir / name.replace('/', '_')
                            cert_file.write_bytes(cert_data)
                            
                            self.findings.append({
                                'category': 'certificate',
                                'file': name,
                                'extracted': str(cert_file)
                            })
            except Exception as e:
                self.errors.append(f"Certificate extraction failed: {e}")
    
    # ========================================================================
    # REPORTING
    # ========================================================================
    
    def _generate_summary(self) -> Dict:
        """Generate test summary"""
        return {
            'timestamp': datetime.now().isoformat(),
            'operation': self.operation,
            'device_serial': self.serial,
            'device_rooted': self.device_info.rooted if self.device_info else False,
            'apps_analyzed': len(self.app_profiles),
            'vulnerabilities_found': len(self.vulnerabilities),
            'critical_vulns': len([v for v in self.vulnerabilities if v.get('severity') == 'CRITICAL']),
            'high_vulns': len([v for v in self.vulnerabilities if v.get('severity') == 'HIGH']),
            'medium_vulns': len([v for v in self.vulnerabilities if v.get('severity') == 'MEDIUM']),
            'low_vulns': len([v for v in self.vulnerabilities if v.get('severity') == 'LOW']),
            'findings': len(self.findings),
            'errors': len(self.errors),
            'work_directory': str(self.work_dir),
        }


# ============================================================================
# HELP SYSTEM
# ============================================================================

def show_help():
    """Display comprehensive help"""
    help_text = """
╔═══════════════════════════════════════════════════════════════════╗
║      SecV Android Penetration Testing Module v1.0                 ║
║      Complete Mobile Security Assessment Suite                    ║
╚═══════════════════════════════════════════════════════════════════╝

DESCRIPTION:
  Comprehensive Android security testing framework for penetration
  testing, vulnerability assessment, and forensics analysis.

OPERATIONS:
  recon          Device reconnaissance and fingerprinting
  app_scan       Application security analysis
  vuln_scan      Vulnerability scanning
  exploit        Exploitation testing (ethical)
  network        Network traffic analysis
  forensics      Data extraction and forensics
  full           Complete penetration test

PARAMETERS:
  operation      Operation type (default: recon)
  device         Device serial (auto-detect if not specified)
  package        Target package name for app-specific tests

RECON OPERATION:
  • Device fingerprinting
  • Root detection
  • Bootloader status
  • SELinux configuration
  • Security patch level
  • Developer mode detection
  • Encryption status

APP_SCAN OPERATION:
  • Static APK analysis
  • Manifest security audit
  • Permission analysis
  • Component exposure check
  • Code vulnerability scanning
  • Certificate validation
  • Security score calculation

VULN_SCAN OPERATION:
  • Common vulnerability checks
  • Known vulnerable app detection
  • Exposed service enumeration
  • Configuration weaknesses
  • ADB network exposure
  • World-readable file detection

EXPLOIT OPERATION:
  • Intent injection testing
  • SQL injection testing
  • Path traversal testing
  • Exported component exploitation
  • Content provider attacks

NETWORK OPERATION:
  • Traffic capture (requires root)
  • Protocol analysis
  • Insecure connection detection
  • Data leakage identification
  • Certificate validation

FORENSICS OPERATION:
  • System information extraction
  • Application data extraction
  • Database dumping
  • SharedPreferences analysis
  • Log extraction
  • SMS/Contacts extraction (requires root)

REQUIREMENTS:
  Basic: android-tools-adb
  Standard: + aapt, keytool
  Advanced: + apktool, jadx
  Full: + frida, objection

EXAMPLES:
  1. Device reconnaissance:
     use android_pentest
     set operation recon
     run device

  2. Scan specific app:
     use android_pentest
     set operation app_scan
     set package com.example.app
     run device

  3. Full vulnerability scan:
     use android_pentest
     set operation vuln_scan
     run device

  4. Test app for exploits:
     use android_pentest
     set operation exploit
     set package com.target.app
     run device

  5. Capture network traffic:
     use android_pentest
     set operation network
     set package com.target.app
     run device

  6. Extract forensics data:
     use android_pentest
     set operation forensics
     set package com.target.app
     run device

  7. Complete pentest:
     use android_pentest
     set operation full
     set package com.target.app
     run device

VULNERABILITY DETECTION:
  • SQL Injection in Content Providers
  • Hardcoded credentials in code
  • Insecure cryptography usage
  • WebView vulnerabilities
  • Intent hijacking
  • Debuggable applications
  • Backup enabled
  • Cleartext traffic
  • Excessive permissions
  • Exported components
  • Debug certificates
  • Outdated SDK versions

SECURITY FEATURES:
  • Root detection
  • Anti-debugging checks
  • SSL pinning detection
  • Certificate validation
  • Permission analysis
  • Component security audit
  • Data storage security
  • Network security assessment

OUTPUT:
  • Detailed security reports
  • Vulnerability findings
  • Risk assessments
  • Exploitation proof-of-concepts
  • Forensics artifacts
  • Recommendations

ETHICAL USE:
  ⚠️  AUTHORIZATION REQUIRED
  • Only test devices you own or have permission to test
  • Respect privacy and data protection laws
  • Follow responsible disclosure practices
  • Use for security research and education only

AUTHOR: SecVulnHub Team | Enhanced by 0xb0rn3
VERSION: 1.0
"""
    print(help_text)


# ============================================================================
# MAIN EXECUTION
# ============================================================================

def main():
    """Main execution"""
    # Check for help
    if len(sys.argv) > 1 and sys.argv[1] in ['--help', '-h', 'help']:
        show_help()
        sys.exit(0)
    
    try:
        # Read context from stdin
        context = json.loads(sys.stdin.read())
        
        # Create pentester
        pentester = AndroidPentester(context)
        
        # Execute test
        result = pentester.execute()
        
        # Output result
        print(json.dumps(result, indent=2))
        
    except KeyboardInterrupt:
        print(json.dumps({
            "success": False,
            "errors": ["Test interrupted by user"]
        }))
        sys.exit(1)
    except Exception as e:
        print(json.dumps({
            "success": False,
            "errors": [f"Unexpected error: {e}"]
        }), file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
